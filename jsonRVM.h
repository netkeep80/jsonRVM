/*        c
       v__|__m
     m   _|_   v
  c__|__/_|_\__|__c  jsonRVM
     |  \_|_/  |     json Relations (Model) Virtual Machine
     v    |    m     https://github.com/netkeep80/jsonRVM
        __|__
       /  |  \
      /___|___\
Fractal Triune Entity

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
Copyright © 2016 Vertushkin Roman Pavlovich <https://vk.com/earthbirthbook>.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
/*
------------------------------------------------------------------------------
		От автора

	Модель отношений (МО) возникла, как попытка найти единый концептуальный атом
их которых состоят все программы. В основе существующих методологий программирования
всегда лежат две концепции: это объект (или структура) и метод (или функция).

	МО это попытка переосмыслить программирование и взглянуть на него как на 
прикладнуюя философию.

	В МО всё построено на основе единой концепции - сущности, которая в зависимости
от своей внутренней реляционной топологии может быть как объектом так и методом.
Сущность по своей структуре триедина, т.к. объединяет в себе 3 связи с другими
(или же с самой собой) сущностями. Каждая из 3х связей имеет своё уникальное значение
и характеризует то качество в котором выступает связанная сущность. Всего существует 
3 типа связи: субъект, отношение, объект.
	Таким образом каждая сущность есть экземпляр определённого отношения между определённым
субъектом и определённым объектом.

	У сущности есть 3 качества, в которых она может проявиться в других сущностях:

1. объект определяющий модель
2. субъект определяющий представление
3. отношение определяющий контроллер

	У каждого проявления качества есть 3 определяющих параметра:

1. сущность, которая проявляет качество:
	объекта		,	субъекта		,	отношения
2. сущность, в которой проявляется одно из качеств другой сущности:
	модель		,	представление	,	контроллер
3. сущность, характеризующая качество проявления:
	объективное	,	субъективное	,	качественное

	С точки зрения ООП сущность это активный объект, который одновременно может обладать
и состоянием и выполнять определённую функцию.

	В начале этого файла идёт терминологический словарь, в котором представлены
термины из независимых источников информации.

	Комментарии расположенные ниже не имеют определённой общей структуры, потому что,
представляют из себя разрозненные мысли записанные в разное время на тему МО.	
	Однако каждый комментарий помечен отдельным иерархическим тэгом, что позволит в
будущем сгенерировать единый структурированный и упорядоченный документ с описанием МО.

------------------------------------------------------------------------------
		Терминологический словарь

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D1%8C
		Су́щность (др.-греч. οὐσία, ὑπόστᾰσις; лат. essentia, substantia) — смысл данной вещи,
то, что она есть сама по себе, в отличие от всех других вещей и в отличие от изменчивых
(под влиянием тех или иных обстоятельств) состояний вещи[1].

По Э. Корету[2], сущность — внутренне конститутивный принцип конечного сущего,
через ограничение и выделение его из иных содержаний бытия конституирующий его определённость.
В отличие от бытия (которое есть принцип полагания, позитивности) — сущность есть принцип негативный,
принцип ограничения: через (относительное) отрицание иных содержаний бытия сущность,
с одной стороны, негативным образом ограничивает, выделяет данное конечное сущее из других;
а с другой стороны, благодаря определённому характеру каждого отрицания,
позитивным образом придаёт данному конечному сущему определённость содержания,
смысловой образ данного конечного сущего.
Благодаря негативности ограничения сущность осуществляет позитивность сущностных
и смысловых образов конечных вещей. С сущностью возникает конкретная определённость сущего.
Благодаря своей сущности конечное сущее выделяется как относительное из абсолютного,
как конечное из бесконечного бытия. В метафизике сущность понимается как не принадлежащая ни бытию,
ни не-бытию, как «нечто среднее между ними»: как потенция,
возможность бытия по отношению к действительности бытия.
Говоря простым языком, сущностью называется то, благодаря чему нечто есть то, что оно есть.

В логике сущность (как существенный признак — лат. essentialia constitutiva) — это неотъемлемое качество,
без которого предмет невозможно мыслить. Сущность предмета выражается в его определении.

В просторечии синонимами слова сущность часто являются слова «суть», «идея», «назначение», «функция».

Сущность выявляется ответом на вопрос: «Что есть сущее?»,
который следует отличать от вопроса о бытии: «Есть ли?» («Существует ли?»).

		Сущность и субстанция

В развитии мысли о бытии категория сущности предшествует категории субстанции,
как предполагающая меньшую отчётливость разграничивающей, рассудочной деятельности.
Затем, с выработкой мысли о субстанции сущность отождествляется с её атрибутами.
Что касается отношения сущности к акциденту и модусу, то в одном смысле она их исключает,
в другом — отождествляется с ними. Как постоянный предикат субстанции,
сущность её не есть ни акцидент, ни модус; но и акцидент,
и модус как таковые имеют свою сущность, то есть свои постоянные предикаты.

Отношение сущности предмета к его субстанции есть отношение постоянных предикатов
к постоянному же субъекту и что, таким образом, по отношению к субстанции понятие
сущности совпадает с понятием атрибутов. Но отношением к понятию субстанции не выясняется
во всей полноте смысл понятия сущности. Постоянные предикаты предмета могут существовать
при разной степени определённости и постоянства его субъекта, и потому сущность не всегда
соотносительна субстанции.

Предмету может быть приписываемо неопределённое, не возведённое к отчётливости мысли бытие
— и такому неопределённому и неотчётливому субъекту могут, тем не менее,
принадлежать постоянные свойства, составляющие его сущность. С другой стороны,
предмет может заведомо иметь для мысли лишь условные постоянство и самостоятельность,
то есть субстанциальность его может быть отрицаема и, тем не менее,
ему можно приписывать постоянную природу или сущность. Это последнее соображение указывает
на неправильность очень часто встречающегося в философии противоположения между сущностью и явлением.

		Сущность и явление

Явление есть все то, чему принадлежит не бытие в точном значении этого слова,
но существование, то есть бытие обусловленное, зависимое. Не имея, таким образом,
само в себе субстанции, явление, однако, также имеет свою сущность,
то есть постоянные предикаты. Следовательно, противоположение существует не между
явлением и сущностью, а между явлением и тем сущим, которое служит первоисточником явления,
или, пожалуй, между сущностью явления и сущностью этого сущего. Эта особенность
понятия сущности может быть кратко выражена так, что для сущности,
как постоянного предиката, необходим субъект логический, но нет необходимости
в субъекте действительном.

В диалектическом материализме сущность и явление представляют собой одну из
«диалектических пар» категорий.

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_(%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F)
	Объе́кт (лат. objectum «предмет») — философская категория, обозначающая вещь,
явление или процесс, на которые направлена предметно-практическая, управляющая
и познавательная деятельность субъекта (наблюдателя); при этом, в качестве
объекта может выступать и сам субъект. Субъектом может быть личность,
социальная группа или всё общество.

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_(%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F)
	Субъе́кт (лат. subjectum «лежащее внизу; находящееся в основе») — носитель
деятельности, сознания и познания[1]; индивид, познающий внешний мир (объект)
и воздействующий на него в своей практической деятельности; человек или
консолидированная группа лиц (напр., научное сообщество), общество, культура
или даже человечество в целом, противопоставляемые познаваемым или
преобразуемым объектам[2].

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE
	Сво́йство (в философии, математике и логике) — атрибут предмета (объекта).
Например, о красном предмете говорится, что он обладает свойством «красноты».
Свойство можно рассматривать как форму предмета самого по себе, притом, что он
может обладать и другими свойствами. Свойства, следовательно, подпадают под
действие парадокса Рассела и парадокса Греллинга-Нельсона.

	По другому определению, свойство — сторона проявления качества. При этом
не всякое свойство предмета (объекта) должно рассматриваться при определении
качества: свойство у предмета может иметься, но при сравнении предмета с другими
оно может не быть отличительным или существенным.

	Свойства объекта зависят от вида взаимодействия объекта и субъекта, например:
если на яблоко смотреть — оно имеет цвет и форму; если его откусить — имеет
твёрдость и вкус; если его взвешивать — имеет вес; если оценивать его
габариты — имеет размеры, если трогать — имеет шероховатость. Объект является
своими свойствами не только субъекту, но и другим объектам, то есть свойства
могут проявляться и в ходе взаимодействия объектов друг с другом.

	Совокупность некоторых частных свойств предмета может проявляться в
некотором обобщённом свойстве предмета (поглощаться обобщённым свойством).
Например, «краснота» яблока — обобщённое свойство яблока, а процентные доли
содержания отдельных химических веществ в кожице яблока (характеризующие эту
«красноту» яблока) — частные свойства яблока; «динамика» автомобиля — обобщённое
свойство автомобиля, а мощность двигателя, снаряжённая масса, отношение главной
передачи и др. (характеризующие эту «динамику» автомобиля) — частные свойства автомобиля.

	Свойство отличается от логического понятия класса тем, что не связано с
понятием экстенсиональности, а от философского понятия класса — тем, что
свойство рассматривается в качестве отличного (отделённого) от предмета,
который обладает им. 

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C
	Информационная модель — модель объекта, представленная в виде информации,
описывающей существенные для данного рассмотрения параметры и переменные
величины объекта, связи между ними, входы и выходы объекта и позволяющая путём
подачи на модель информации об изменениях входных величин моделировать
возможные состояния объекта[1].

	Информационная модель (в широком, общенаучном смысле) — совокупность
информации, характеризующая существенные свойства и состояния объекта,
процесса, явления, а также взаимосвязь с внешним миром. 

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%AF%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F)
	Явле́ние — вообще всё, что чувственно воспринимаемо; особенно бросающееся в
каком-то отношении в глаза (например, какое-либо явление природы).

	С точки зрения теории познания явление есть выражение, свидетельство наличия
чего-то другого; так, высокая температура есть явление болезни, то есть болезнь
извещает о себе посредством высокой температуры, она проявляется через эту
температуру. В философии Канта явление — коррелятивное понятие к «вещи-в-себе».
Н. Гартман говорит: сущее в себе (см. Познание) есть являющееся в явлении.
Иначе явление было бы пустой видимостью. «Я познаю нечто» и «нечто является мне»
— два выражения, обозначающие одно и то же отношение между субъектом и объектом
(см. Видимость). Противоположность между явлением и сущим-в-себе выступает наиболее
резко в инд. философии (см. Шанкара); в европейской мысли эта противоположность
выступает в христианстве в противопоставлении посюстороннего и потустороннего и
выражает собой определённый, не только теоретический, скепсис; см. также Иллюзионизм,
Феноменализм.

	Явле́ние — совокупность процессов материально-информационного преобразования,
обусловленных общими причинами. С точки зрения наблюдателя может быть:

    постоянным;
    периодическим;
    эпизодическим.

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE_(%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F)
	Ка́чество — философская категория, выражающая совокупность существенных
признаков, особенностей и свойств, которые отличают один предмет или явление
от других и придают ему определённость. Качество предмета или явления, как
правило, не сводится к отдельным его свойствам. Оно связано с предметом как
целым, охватывает его полностью и неотделимо от него. Поэтому понятие качества
связывается с бытием предмета. Предмет не может, оставаясь самим собой,
потерять своё качество. Например, переход в новое качество. 

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%B6%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C
	Кажимость (видимость) — философская (логическая) категория, означающая
превратное определение истинного бытия, основанное на чувственно-воспринимаемом,
внешнем явлении предмета познания.

	Кажимость есть абстракция любой истинной сущности для чувственного или
(что то же самое) рассудочного мышления, принимающего за истину вещи (предмета
познания) только то, что непосредственно дано ему в чувственном восприятии
(познании) этой вещи. В кажущейся полноте чувственного восприятия внешних вещей
рассудок действительно фиксирует только их поверхностные свойства, принимая
случайные явления и связи таковых за истинное (существенные определения) бытие
данных вещей. Следовательно, рассудочное мышление в своих результатах
(представлениях) всегда имеет дело только с видимостью истины, её абстрактным
проявлением, кажущимся рассудку истиной во всей полноте.

	Различие между кажимостью и действительностью истины (сущности вещи)
выступает только в логической форме разумного мышления, в котором снимается
противоположность внешнего и внутреннего отношения сторон, содержащихся в
предмете познания, устанавливается их взаимная необходимость. Все прочие
способы и формы познания (рассудочные, формально-логические) по причине
ограниченности их мыслительных возможностей, обусловленной зависимостью от
чувственного восприятия с одной стороны, разделением познающего сознания и
познаваемого предмета — с другой, имеют дело только с видимостью истины в
вещах — принимают только кажущиеся истинными внешние, чувственно-данные
проявления вещей за их истину. На этом основании в опытных науках и связанных
с ними рассудочных учений в философии и формальной логике возникают и
развиваются формы мировоззрений, принципиально отрицающих познаваемость истины:
агностицизм, скептицизм, стоицизм. Современными формами таких мировоззрений
выступают: в философии — все направления позитивизма и пост-модернизма, в
опытных науках — попытки создания «единых», «общих», «не-противоречивых»
эмпирических теорий (картин) всех вещей во Вселенной и Вселенной вообще.
Сторонники подобных взглядов на истину, однако же, склонны находить причины
логической и фактической ошибочности своих мировоззрений и теорий в самих вещах,
а не ограничениях самого рассудочного способа познания вещей. Критика
рассудочного мышления и наука мышления разумного дана и разработана Г. В. Ф.
Гегелем в «Феноменологии духа» и «Науке логики». Там же можно найти точное
определение категории «видимость» (кажимость). 

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/%D0%90%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82_(%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F)
	Атрибу́т — существенный, неотъемлемый признак предмета или явления (в отличие
от преходящих, случайных его состояний) — то, что составляет сущность субстанции,
её фундаментальное свойство, необходимый для её существования предикат[1].

	Атрибуты совершенно независимы, то есть не могут влиять друг на друга.
Однако как для субстанции в целом, так и для каждой отдельной вещи выраженность
существования через атрибут протяжения и мышления согласуются: «Порядок и связь
идей те же, что порядок и связь вещей»[2]. 

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/Model-View-Controller
Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер»)
— схема разделения данных приложения, пользовательского интерфейса и управляющей
логики на три отдельных компонента: модель, представление и контроллер — таким образом,
что модификация каждого компонента может осуществляться независимо[1].

Модель (Model) предоставляет данные и реагирует на команды контроллера,
изменяя свое состояние[1].

Представление (View) отвечает за отображение данных модели пользователю,
реагируя на изменения модели[1].

Контроллер (Controller) интерпретирует действия пользователя, оповещая модель
о необходимости изменений[1].

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/HMVC
HMVC (англ. Hierarchical model–view–controller) — Иерархические Модель-Вид-Контроллер,
одно из расширений архитектурного паттерна MVC, позволяющее решить некоторые
проблемы масштабируемости приложений, имеющих классическую MVC-архитектуру.

Впервые описано в 2000-м году[1], в одной из статей блога JavaWorld, но
некоторые разработчики отмечают, что оно, по сути, является переосмыслением
более строгого паттерна PAC (рус.)англ. (англ. Presentation-Abstraction-Control),
описанного в 1987 году.

Согласно парадигме HMVC, каждая отдельная MVC триада используется в качестве
слоя в иерархической структуре. При этом, каждая триада в этой иерархии независима
от других, и может обратиться к контроллеру другой триады. Такой подход существенно
облегчает и ускоряет разработку сложных приложений, облегчает их дальнейшую
поддержку и масштабирование, способствует повторному использованию кода.

------------------------------------------------------------------------------
MHMVC (Multilayered Hierarchical Model-View-Controller), т.е. в Многослойный
Иерархический Модель – Вид – Контроллер. В данной концепции иерархия представлений
одного слоя может служить в качестве иерархии модели для следующего слоя и наоборот,
что позволяет гибко реализовать многослойную архитектуру приложения.

При реализации этой концепции в коде, было так же применено тактическое
решение, объединить в каждом слое данных классы представлений и классы контроллеров
через наследование представлений от контроллеров для упрощения архитектуры и
уменьшения общего количества классов в коде в 2 раза.

------------------------------------------------------------------------------
https://ru.wikipedia.org/wiki/JSON
	JSON (англ. JavaScript Object Notation, обычно произносится как /ˈdʒeɪsən/
JAY-sən [1]) — текстовый формат обмена данными, основанный на JavaScript. Как и
многие другие текстовые форматы, JSON легко читается людьми.

	Формат JSON был разработан Дугласом Крокфордом[2].

	Несмотря на происхождение от JavaScript (точнее, от подмножества языка стандарта
ECMA-262 1999 года), формат считается независимым от языка и может использоваться
практически с любым языком программирования. Для многих языков существует готовый
код для создания и обработки данных в формате JSON.

	JSON-текст представляет собой (в закодированном виде) одну из двух структур:
Набор пар ключ: значение. В различных языках это реализовано как объект, запись,
структура, словарь, хэш-таблица, список с ключом или ассоциативный массив.
Ключом может быть только строка (регистрозависимая: имена с буквами в разных
регистрах считаются разными[3]), значением — любая форма. Упорядоченный набор
значений. Во многих языках это реализовано как массив, вектор, список или
последовательность.

	Это универсальные структуры данных: как правило, любой современный язык
программирования поддерживает их в той или иной форме. Они легли в основу JSON,
так как он используется для обмена данными между различными языками программирования.

	В качестве значений в JSON могут быть использованы:

Объект — это неупорядоченное множество пар ключ:значение, заключённое в фигурные
	скобки «{ }». Ключ описывается строкой, между ним и значением стоит символ «:».
	Пары ключ-значение отделяются друг от друга запятыми.

Массив (одномерный) — это упорядоченное множество значений. Массив заключается
	в квадратные скобки «[ ]». Значения разделяются запятыми.
Число.
Литералы true, false и null.
Строка — это упорядоченное множество из нуля или более символов юникода,
заключённое в двойные кавычки. Символы могут быть указаны с использованием
escape-последовательностей, начинающихся с обратной косой черты «\»
(поддерживаются варианты \", \\, \/, \t, \n, \r, \f и \b), или записаны
шестнадцатеричным кодом в кодировке Unicode в виде \uFFFF.

------------------------------------------------------------------------------
		Сокращения 

СОП - сущностно ориентированное программирование
МО  - модель отношений
РВМ - реляционная виртуальная машина, исполняющая модель отношений

EOP - entity oriented programming
RVM - relations virtual machine
RM  - relations model

------------------------------------------------------------------------------
#/RM/jsonView
Представление МО в json (json явление/проекция МО) это объектное представление модели отношений в сегменте данных RVM.
Проекция сущности это то как она отображается субъекту наблюдения, поэтому json представление хранится в контексте отображения.
Представление МО в json бывает 3х видов:
1. в виде структур описывающих отдельные сущности
2. упрощенная модель в виде json структур и массивов

------------------------------------------------------------------------------
#/json
Сам по себе json не является языком программирования МО, поэтому для исполнения
МО требуется подгрузка json в сегмент данных РВМ, а так же подгрузка базовых
словарей сущностей для данной РВМ.

------------------------------------------------------------------------------
#/RM/jsonView
В дереве значений json, где значения проекций сущностей известно, находятся
обычные значения json. В тех местах, где требуется вычислить json проекцию,
находится json объект с дополнительными свойствами "<-", "()", "->", "=".
Такой объект интерпретируется RVM как сущность МО, которую можно исполнить и
найти её проекцию. Сущности могут иметь дополнительные поля в которых
закэшированы проекции или заданы сущности создающие проекции данных свойств.

------------------------------------------------------------------------------
#/RM/jsonView
Любое значение json можно представить эквивалентной МО, json проекция которой
будет идентична этому json значению.

------------------------------------------------------------------------------
#/Entity
Под термином «сущность» следует понимать «сущую вещь», проще говоря, «что-то».
В МО это функционирующий объект (активный объект).

------------------------------------------------------------------------------
#/RVM/exec
Нахождение результата экземпляра отношения происходит через интерпретацию
сущности (либо исполнение её json проекции) выступающей в качестве отношения
в данном экземпляре. Что бы исполнить сущность, у неё должна быть проекция в
язык который понимает исполнитель, например:
если у нас есть JavaScript виртуальная машина то для неё у сущности должна быть
проекция в js. Если у сущности нет проекции в язык понимаемый имеющимся
исполнителем, то необходимо либо скомпилировать тело сущности (т.е. создать
проекцию в нужный язык), либо интерпретировать экземпляр отношения которым она является.
Сущность при исполнении в качестве отношения в экземпляре отношения может
создать в контексте свойство с именем языка исполнителя и скомпилировать себя
туда для непосредственного исполнения в следующий/этот раз.

------------------------------------------------------------------------------
#/RVM/exec
При исполнении МО существует два потока:
	вертикальный - это поток байткода json
	горизонтальный - это поток данных в json.
Горизонтальные потоки это межслойное преобразование данных контроллерами MVC.
Вертикальные потоки это потоки управления потоки интерпретации json-байткода
контроллеров MVC виртуальной машиной.

------------------------------------------------------------------------------
#/RM/jsonView/types
		Соответсвие json значений - проекциям МО:

1. Number  - топологически замкнутая (т.е. сама в себя) проекция отношения double|int32|int64|uint32|uint64
2. Boolean - топологически замкнутая проекция отношения bool
3. String  - топологически замкнутая проекция отношения string, либо имя сущности
4. Object  - топологически замкнутая проекция отношения, либо сущность если есть поля "<-" или "()" или "->" или "="
5. Array   - топологически замкнутая проекция цепочки отношений ","
6. Null    - пустое пространство под проекцию

Null и Array - это не совсем типы, они принципиально отличаются от типов и их обработка идёт отдельными кейсами if
1. Array - это контейнер объектов одного или разного типа
2. Null - это отсутствие объекта любого типа

Начало цепочки отношений "," всегда есть Null:
((Null --","-> SomeEnt1) --","-> SomeEnt2) === jsonArray[SomeEnt1, SomeEnt2]
Это объясняется тем что начало цепочки это то место перед которым нет другого
начала, т.е. пустое пространство.

------------------------------------------------------------------------------
		Алгоритм исполнения json после загрузки:

1. json после десериализации является непостредственно сегментом данных RVM
2. корневое значение json всегда есть корневая сущность загруженной МО,
	которую необходимо исполнить
3. поля указывающие на субъект, отношение и объект могут либо содержать
    сущность по значению (значения: объект, массив)
	либо содержать ссылки на сущность (значения: строка, число)
	либо признак ссылки на контекстную сущность (значения: null)
	либо значение boolean
4. Местоимения при нахождении их проекции возвращают ссылку на элементы контекста,
	проекции которых были найдены до вызова контроллера.

------------------------------------------------------------------------------
#/exec
Самое основное отношение это отношение "#/exec", оно исполняет сущность объекта указанного
в поле "<-" и записывает полученную проекцию в поле "->" субъекта.
Именно это отношение исполняется для кажого поля json объекта, когда он указан
в качестве отношения сущности.

------------------------------------------------------------------------------
		Правила json скрипта:

1. json представляет собой агрегат проекций сущностей т.е. иерархию МО по сущности-субъекту,
2. местоимение субъекта "->" может являеться сущностью агрегатом проекции
3. запуск скрипта это получение проекции корневой сущности
4. внутри корневой json сущности лежат разные её проекции, либо...
5. внутри корневой json проекции лежит jsonView корневой сущности
6. у локальных не корневых проекций "->" = сущности в которой они лежат
7. если в объекте json есть поле "()", то значит это сущность
8. проекция состоит из проекций, т.о. получается иерархичность
Внутри проекции находятся другие проекции.
Внутри сущности находится иерархия по сущности-субъекту.

Новые сущности могут создаваться в результате проецирования, т.е. по сути являются тоже проекциями.

------------------------------------------------------------------------------
		Варианты взаимоотношений узлов json:

1. Проекция в проекции
2. Сущность в сущности (в полях "<-", "()", "->")
3. Сущность в проекции (в объекте или массиве)
4. Проекция в сущности (в полях "<-", "()", "->", "")
5. Ссылка на сущность в сущности (в полях "<-", "()", "->")
6. Ссылка на сущность в проекции (в поле "/")

------------------------------------------------------------------------------
		О свойствах (атрибутах) и элементах сущности:

У сущности есть как свойства так и элементы.
Элементами сущности являются разные её свойства.
Элементы объекта и есть его свойства если этот объект не сущность.
Свойства (properties) сущности есть элементы (elements) её представления (view).
(Entity properties are elements of its view).

https://books.google.ru/books?id=VfcX9wJEH3YC&pg=PT42&redir_esc=y&hl=ru#v=onepage&q&f=false

Сущность это то что является субъекту при наблюдении объекта через призму отношения их связывающего.
Таким образом сущьность есть результат отношения связывающего объект и субъект.
Субъект вмещает в себя явление сущности объекта.

Результат исполнения сущности это проекция в триаде MVC, но т.к. МО это иерархический многослойный MVC,
то субъект у сущности это родительский View вмещающий проекцию данной сущности.
Таким образом результат проецирования сущности сохраняется в поле "", значение которого состоит из отдельных
проекций агрегируемых сущностей. Следовательно если объект json имеет признак того, что это сущность,
то данный объект json не должен иметь в себе полей с текстовыми названиями, а только: "id", "<-", "()", "->", "/".
Решением данной проблемы может быть вариант когда текстовые поля внутри объекта json будут хранить в себе кэши проекций
данной сущности другими контроллерами (сущностями-отношениями), например:

{
   "id": "this entity english name",
   "RusView": "русское название этой сущности",
   "jsView": "this entity java script view",
   "C#View": "this entity C# code view",
   "<-": "object entity model",
   "()": "relation entity model",
   "->": "subject entity model",
   "=": "this entity default view"
}

------------------------------------------------------------------------------
		Об адресации в json:

1. сущности имеют уникальные названия - английскую проекцию
2. представления имеют иерархическую адресацию по дереву представленией, имена разделены /

------------------------------------------------------------------------------
		Заметки:

1. кэширование проекций сущностей осуществляется только явным образом, через отношение jsonView?
3. для символьных ссылок указанных в качестве субъекта, отношения или объекта сущности должна быть найдена указанная сущность

------------------------------------------------------------------------------
		Общая схема модели отношений:

В МО может быть множество корневых сущностей.
У корневых сущностей EntId === SubId.

------------------------------------------------------------------------------
		Семантика json значения в поле "/" у объекта json:

1. Number  - число
2. Boolean - булевый тип = true/false
3. String  - строка
4. Object  - карта свойств
5. Array   - последовательность
6. Null    - отсутствие значения
7. Entity  - json проекция содержащая модель сущности

------------------------------------------------------------------------------
		Семантика json значений в полях "->", "()", "<-" у объекта json:

1. Number  - адрес json объекта в памяти
2. Boolean - проекция сущности = true/false
3. String  - иерархическое имя сущности относительно контекста исполнения
4. Object  - json объект
5. Array   - json массив
6. Null    - топологическая замкнутость на текущую проекцию сущности
7. Entity  - другая сущность

------------------------------------------------------------------------------
		Семантика json значений при исполнении  (json как байткод RVM):

1. Number  - адрес json значения в памяти, которое необходимо исполнить RVM
2. Boolean - прервать исполнение и вернуть в вызывающий контекст значение true/false
3. String  - иерархическое имя json значения относительно контекста исполнения,
				которое необходимо исполнить RVM
4. Object  - множество пар "имя поля": значение поля, где
				имя поля - иерархическое имя json значения относительно контекста исполнения
				значение поля - json значение, которое необходимо исполнить RVM
			исполнение множества пар происходит параллельно
5. Array   - массив значений json которые необходимо последовательность исполнить
				в текущем контексте исполнения, при этом результат предыщущего
				исполнения всегда доступен для следующей исполняющейся сущности
6. Null    - отсутствие действия, эквивалент NOP
7. Entity  - сущность, которую надо исполнить в дочернем контексте исполнения

------------------------------------------------------------------------------
		Программирование на МО

Контекстно зависимая проекция сущности может быть получена в результате
исполнения (или нахождения) отношения "()" в контексте субъекта "->" и объекта "<-".
Сущность может использовать контекстно зависимые местоимения в своей модели,
таким образом реализуется контекстно зависимость проекции сущности.

*/
#pragma once
#ifndef NLOHMANN_JSON_FWD_HPP
#define NLOHMANN_JSON_FWD_HPP

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

namespace nlohmann
{
	template<typename = void, typename = void>
	struct adl_serializer;

	template<template<typename U, typename V, typename... Args> class ObjectType =
		std::map,
		template<typename U, typename... Args> class ArrayType = std::vector,
		class StringType = std::string, class BooleanType = bool,
		class NumberIntegerType = std::int32_t,
		class NumberUnsignedType = std::uint32_t,
		class NumberFloatType = float,
		template<typename U> class AllocatorType = std::allocator,
		template<typename T, typename SFINAE = void> class JSONSerializer =
		adl_serializer>
		class basic_json;

	template<typename BasicJsonType>
	class json_pointer;

	using json = basic_json<>;
}
#endif
#include "./nlohmann/json.hpp"

using namespace std;
using namespace nlohmann;

class jsonPtr
{
	union
	{
		size_t	_ptr;
		json*	jptr;
	};
public:
	jsonPtr() : _ptr(0) {}
	jsonPtr(json* ptr) : jptr(ptr) {}
	jsonPtr(const size_t ptr) : _ptr(ptr) {}
	json* operator->() { return jptr; }
	const json* operator->() const { return jptr; }
	json& operator*() const { return *jptr; }
	operator json*() const { return jptr; }
	operator json() const { return json(_ptr); }
	operator size_t() { return _ptr; }
	operator size_t() const { return _ptr; }
};

namespace nlohmann
{
	namespace detail
	{
		inline void to_json(json& j, jsonPtr p) { j = (size_t)p; }
		inline void from_json(const json& j, jsonPtr& p) { p = j.get<size_t>(); }
	}
}

class Entity;
typedef void (__fastcall *x86View)(Entity &Ctx, json &Value);


#define IMPORT_RELATIONS_MODEL "?ImportRelationsModel@@YIXAAV?$basic_json@Vmap@std@@Vvector@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_NHIMVallocator@2@Uadl_serializer@nlohmann@@@nlohmann@@@Z"
//#define IMPORT_RELATIONS_MODEL "?ImportRelationsModel@@YIXAAV?$basic_json@Vmap@std@@Vvector@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@_NHINVallocator@2@Uadl_serializer@nlohmann@@@nlohmann@@@Z"
__declspec(dllexport) void __fastcall ImportRelationsModel(json &Ent);
typedef void (__fastcall *InitDict)(json &Ent);
static InitDict	You_must_define_ImportRelationsModel_function_in_your_RM_dictionary = ImportRelationsModel;

//	для отладки
class PushCS
{
	vector<string> &CallStack;
public:
	PushCS::PushCS(const string& name, vector<string> &cs, int level) : CallStack(cs)
	{ CallStack.push_back("L"s + to_string(level) + ": "s + name); }
	PushCS::~PushCS()
	{ CallStack.pop_back();	}
};

#ifdef _DEBUG
#define	CSPush(name)	PushCS LevelName(name, *EV.CallStack, EV.ctx_level);
#else
#define	CSPush(name)
#endif

template<class _T>
vector<_T> split(const _T& str, const _T& delim, bool find_empty = false)
{
	vector<_T> tokens;
	size_t prev = 0, pos = 0;
	do
	{
		pos = str.find(delim, prev);
		if (pos == _T::npos) pos = str.length();
		_T token = str.substr(prev, pos - prev);
		if (!token.empty() || find_empty) tokens.push_back(token);
		prev = pos + delim.length();
	} while (pos < str.length() && prev < str.length());
	return tokens;
}


/*
		TODO:

1. заменить CallStack на json
2. заменить конструктор Entity на InitCTX
3. заменить map<string, json*> на map<string, json>
4. заменить Entity& parent на json
5. перенести int ctx_level в json
6. заменить Entity на json
*/

inline void		InitCTX(Entity &EV, json& ent_ref, json &Value);
inline void		ErrorMessage(Entity &EV, const string &Name, const string &Message);
inline json*	ReferEntity(Entity &EV, json &Ent, json &Value);
inline void		ViewEntity(Entity &EV, json &Ent, json &Value);
inline void		ExecEntity(Entity &EV, json &Ent, json &Value);

//	контекст исполнения экземпляра отношения
//	содержит только указатели на json проекции сущностей
//ToDo: переделать на jsonPtr
class Entity : public map<string, json*>
{
public:
#ifdef _DEBUG
	int				ctx_level;	//	для отладки
	vector<string>*	CallStack;	//	для отладки
#endif
	Entity&		parent;		//	родительский контекст, перенесем в последнюю очередь

#ifdef _DEBUG
	Entity(Entity& pRef, json& ent_ref, json &Value) : ctx_level(pRef.ctx_level + 1),  parent(pRef), CallStack(pRef.CallStack)
#else
	Entity(Entity& pRef, json& ent_ref, json &Value) : parent(pRef)
#endif
	{
		Entity&	EV = *this;
		EV["#"] = pRef["#"];	//	'#' - root entity model
		InitCTX(EV, ent_ref, Value);
	}

#ifdef _DEBUG
	Entity(json& root_ref, vector<string> *cs, json &Value) : ctx_level(0), parent(*this), CallStack(cs)
#else
	Entity(json& root_ref, vector<string> *cs, json &Value) : parent(*this)
#endif
	{
		Entity&	EV = *this;
		EV["#"] = &root_ref;	//	'#'	- root entity model
		InitCTX(EV, root_ref, Value);
	}
};


inline void InitCTX(Entity&	EV, json& ent_ref, json &Value)
{
	try		//	процедура проецирования сущности в контекст исполнения, объёдинить с jsonView
	{
		//	у сущности должны быть поля '<-', '()', '->' с указателями на сущности или значениями типа: сущность, структура, массив
		if (!ent_ref.count("<-"))	ent_ref["<-"] = json();	//	объект не отличается от самой сущности
		if (!ent_ref.count("->"))	ent_ref["->"] = json();	//	субъект не отличается от самой сущности
		EV["ent"] = &ent_ref;			//	'ent'	- entity model
		EV[""] = &Value;				//	''	- entity view, points to Value
		EV["<-"] = ReferEntity(EV.parent, ent_ref["<-"], Value);
		EV["()"] = ReferEntity(EV.parent, ent_ref["()"], Value);
		EV["->"] = ReferEntity(EV.parent, ent_ref["->"], Value);
	}
	catch (...)
	{
		ErrorMessage(EV, "InitCTX"s, "Exception, may be parent of ent_ref was changed!"s);
		Value = json();
	}
}

inline void ErrorMessage(Entity &EV, const string &Name, const string &Message)
{
	json &Ent = *EV["ent"];
	Ent["errors"][Name] = Message;
}

inline json* ReferEntity(Entity &EV, json &Ent, json &Value)
{
	Entity*	ctx = &EV;
	switch (Ent.type())
	{
	case json::value_t::string:		//	hierarchical address in projected ent view
	{
		const string&	String = Ent.get<string>();
		//if (EV.find(String) != EV.end()) return *EV[String];	//ToDo:	strong reference cashing
		auto			path = split(String, "/"s, true);
		json*			res = nullptr;

		for (auto it : path)
		{
			if (nullptr == res)	//	контекст определён?
			{
				if (ctx->find(it) != ctx->end())
					res = (*ctx)[it];
				else if ("ctx"s == it)
					ctx = &ctx->parent;
				else
					throw(__FUNCTION__ + ": pronoun '"s + it + "' does not exist in entity context!"s);
			}
			else try
			{
				if (res->is_array())
				{
					res = &(*res)[std::stoul(it)];
				}
				else if (res->is_object())
				{
					res = &(*res)[it];
				}
				else if (res->is_null())
				{
					try {
						*res = json::array();
						res = &(*res)[std::stoul(it)];
					}
					catch (...)	//	это не число
					{
						*res = json::object();
						res = &(*res)[it];
					}
				}
				else throw it;
			}
			catch (invalid_argument e)
			{
				throw(__FUNCTION__ + ": property '"s + String + "' invalid_argument, " + e.what());
			}
			catch (out_of_range e)
			{
				throw(__FUNCTION__ + ": property '"s + String + "' out_of_range, " + e.what());
			}
			catch (...)
			{
				throw(__FUNCTION__ + ": property '"s + String + "' does not exist!");
			}
		}

		//EV[String] = res;	//ToDo:	strong reference cashing
		return res;
	}

	//	абсолютный адрес сущности
	case json::value_t::number_float:
	case json::value_t::number_integer:
	case json::value_t::number_unsigned:
		return (json*)(Ent.get<uint64_t>());

		//	местоимение проекции контекстной сущности
	case json::value_t::null:
		return &Value;

		//	если это не адрес то возвращаем значение
	default:
		return &Ent;
	}
}

//	получение проекции сущности
inline void ViewEntity(Entity &EV, json &Ent, json &Value)
{
	CSPush("view : "s + Ent.dump());	//	debug
										//	если свойство и есть сама сущность то возвращаем текущую проекцию сущности
	if (&Value == &Ent)
		return;
	else switch (Ent.type())
	{
	case json::value_t::object:
		try
		{
			if (Ent.count("/"))	//	это сущность с закэшированной дефолтной проекцией?
			{	//	приоритет у закэшированной проекции выше
				Value = Ent["/"];
			}
			else if (Ent.count("@"))		//	это скомпилированная сущность?
			{
				json& x86Exec = Ent["@"];
				switch (x86Exec.type())
				{
				case json::value_t::number_unsigned:	//	адрес скомпилированной сущности
				{
					x86View	entBody = (x86View)x86Exec.get<json::number_unsigned_t>();
					entBody(EV, Value);
					return;
				}

				default:
					Value = json();
					throw(__FUNCTION__ + ": wrong Ent['@'] json type '"s + x86Exec.dump() + "'"s);
				}
			}
			else if (Ent.count("()"))	//	это сущность, которую надо исполнить в новом контексте?
			{
				Entity	ctx(EV, Ent, Value);	//	создаём контекстную проекцию сущности
				CSPush("() : "s + Ent["()"].dump());	//	debug
				json&	relRef = *ctx["()"];
				ExecEntity(ctx, relRef, Value);
			}
			else
				Value = Ent;
		}
		catch (string& error)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "exception: "s + error);
		}
		catch (json::exception& e)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "exception: "s + e.what() + ", exception id: "s + to_string(e.id));
		}
		catch (...)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "unknown exception"s);
		}
		return;

		//	во всех остальных случаях проекция просто копируется
	default:
		Value = Ent;
	}
}

//	Исполнение сущности либо json байткода
//	имеет прототип отличный от других контроллеров и не является контроллером
//	рекурсивно раскручивает структуру проекции контроллера доходя до простых json или вызовов скомпилированных сущностей
inline void ExecEntity(Entity &EV, json &Ent, json &Value)
{
	CSPush("exec : "s + Ent.dump());	//	debug
	switch (Ent.type())
	{
	case json::value_t::object:
		try
		{
			if (Ent.count("/"))	//	это сущность с закэшированной дефолтной проекцией?
			{	//	приоритет у закэшированной проекции выше
				Value = Ent["/"];
			}
			else if (Ent.count("@"))		//	это скомпилированная сущность?
			{
				json& x86Exec = Ent["@"];
				switch (x86Exec.type())
				{
				case json::value_t::number_unsigned:	//	адрес скомпилированной сущности
				{
					x86View	entBody = (x86View)x86Exec.get<json::number_unsigned_t>();
					entBody(EV, Value);
					return;
				}

				default:
					Value = json();
					throw(__FUNCTION__ + ": wrong Ent['@'] json type '"s + x86Exec.dump() + "'"s);
				}
			}
			else if (Ent.count("()"))	//	это сущность, которую надо исполнить в новом контексте?
			{
				Entity	ctx(EV, Ent, Value);	//	создаём контекстную проекцию сущности
				CSPush("() : "s + Ent["()"].dump());	//	debug
				json&	relRef = *ctx["()"];
				ExecEntity(ctx, relRef, Value);
			}
			else   //	контроллер это лямбда структура, которая управляет параллельным проецированием сущностей
			{	//ToDo:	надо переделать на параллельное проецирование
				for (auto& it : Ent.items())
				{
					const string&	key = it.key();
					CSPush(key);	//	debug
									//	проецируем в текущем контексте
					json&	subRef = *ReferEntity(EV, json(key), Value);
					json&	objRef = *ReferEntity(EV, it.value(), Value);
					ViewEntity(EV, objRef, subRef);
				}
			}
		}
		catch (string& error)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "exception: "s + error);
		}
		catch (json::exception& e)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "json::exception: "s + e.what() + ", exception id: "s + to_string(e.id));
		}
		catch (std::exception& e)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "std::exception: "s + e.what());
		}
		catch (...)
		{
			string	name = Ent.count("name") ? Ent["name"].get<string>() : "";
			ErrorMessage(EV, name, "unknown exception"s);
		}
		return;

		//	лямбда вектор, который управляет последовательным изменением проекции сущности
	case json::value_t::array:
	{
		int i = 0;	//	debug
		for (auto& it : Ent)
		{
			CSPush("["s + to_string(i++) + "]"s);	//	debug
													//	сохраняем результат исполнения как проекцию сущности
			ExecEntity(EV, it, Value);
		}
		return;
	}

	//	абсолютный адрес сущности
	case json::value_t::number_float:
	case json::value_t::number_integer:
	case json::value_t::number_unsigned:
	{
		json&	entRef = *(json*)(Ent.get<uint64_t>());
		ExecEntity(EV, entRef, Value);
		return;
	}

	//	иерархическая символьная ссылка в проекции сущности
	case json::value_t::string:
	{
		json&	entRef = *ReferEntity(EV, Ent, Value);
		ExecEntity(EV, entRef, Value);
		return;
	}

	//	битовая маска для условного проектора ViewEntity
	case json::value_t::boolean:
		if (Ent) ViewEntity(EV, *EV["<-"], *EV["->"]);
		return;

		//	null - означает отсутствие отношения, т.е. неизменность проекции
	default:
		return;
	}
}

//	добавление сущности с закэшированной x86 проекцией
inline json&	Addx86Entity(json& Subject, const string& Name, x86View View, const string& Description)
{
	Subject[Name] = json::object();
	Subject[Name]["@"] = (size_t)View;
	Subject[Name]["name"] = Name;
	Subject[Name]["description"] = Description;
	return Subject[Name];
}

#pragma warning (disable: 4244)

inline bool get_bool(const json& obj, const string& field)
{
	if (obj.count(field))
	{
		const json& val = obj[field];
		switch (val.type())
		{
		case json::value_t::number_float:   return bool(val.get<json::number_float_t>() != 0.0);
		case json::value_t::number_integer: return bool(val.get<json::number_integer_t>() != 0);
		case json::value_t::number_unsigned:return bool(val.get<json::number_unsigned_t>() != 0);
		case json::value_t::boolean:        return bool(val.get<json::boolean_t>());
		case json::value_t::string:         return bool(val.get_ref<const json::string_t&>() != ""s && val.get_ref<const json::string_t&>() != "false"s);
		default: break;
		}
	}

	return bool();
}


inline float get_float(const json& obj, const string& field)
{
	if (obj.count(field))
	{
		const json& val = obj[field];
		switch (val.type())
		{
		case json::value_t::number_float:   return float(val.get<json::number_float_t>());
		case json::value_t::number_integer: return float(val.get<json::number_integer_t>());
		case json::value_t::number_unsigned:return float(val.get<json::number_unsigned_t>());
		case json::value_t::boolean:        return float(val.get<json::boolean_t>() ? 1.0 : 0.0);
		case json::value_t::string:         return float(std::stod(val.get_ref<const json::string_t&>()));
		default: break;
		}
	}

	return float();
}


inline float get_int(const json& obj, const string& field)
{
	if (obj.count(field))
	{
		const json& val = obj[field];
		switch (val.type())
		{
		case json::value_t::number_float:   return int(val.get<json::number_float_t>());
		case json::value_t::number_integer: return int(val.get<json::number_integer_t>());
		case json::value_t::number_unsigned:return int(val.get<json::number_unsigned_t>());
		case json::value_t::boolean:        return int(val.get<json::boolean_t>() ? 1 : 0);
		case json::value_t::string:         return int(std::stoi(val.get_ref<const json::string_t&>()));
		default: break;
		}
	}

	return int();
}


inline float get_unsigned(const json& obj, const string& field)
{
	if (obj.count(field))
	{
		const json& val = obj[field];
		switch (val.type())
		{
		case json::value_t::number_float:   return unsigned(val.get<json::number_float_t>());
		case json::value_t::number_integer: return unsigned(val.get<json::number_integer_t>());
		case json::value_t::number_unsigned:return unsigned(val.get<json::number_unsigned_t>());
		case json::value_t::boolean:        return unsigned(val.get<json::boolean_t>() ? 1 : 0);
		case json::value_t::string:         return unsigned(std::stoul(val.get_ref<const json::string_t&>()));
		default: break;
		}
	}

	return unsigned();
}

