<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsonRVM: Введение</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="rm_view.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">jsonRVM
   </div>
   <div id="projectbrief">json Relations (Model) Virtual Machine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_2_introduction.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Введение</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md63"></a> В основе основных существующих методологий программирования лежат две базовые концепции, это структура (объект, данные, состояние) и функция (процесс, процедура, метод, алгоритм). В разных методологиях программирования в качестве первичной концепции используется либо первая либо вторая.</p>
<p><a href="https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование">https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование</a> </p><pre class="fragment">    Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования,
основанная на представлении программы в виде совокупности объектов, каждый из которых
является экземпляром определённого класса, а классы образуют иерархию наследования.
    Идеологически ООП — подход к программированию как к моделированию информационных
объектов, решающий на новом уровне основную задачу структурного программирования:
структурирование информации с точки зрения управляемости, что существенно улучшает
управляемость самим процессом моделирования, что, в свою очередь, особенно важно при
реализации крупных проектов.
</pre><p> <a href="https://ru.wikipedia.org/wiki/Функциональное_программирование">https://ru.wikipedia.org/wiki/Функциональное_программирование</a> </p><pre class="fragment">    Функциона́льное программи́рование — парадигма программирования, в которой процесс
вычисления трактуется как вычисление значений функций в математическом понимании последних
(в отличие от функций как подпрограмм в процедурном программировании).
    Противопоставляется парадигме императивного программирования, которая описывает
процесс вычислений как последовательное изменение состояний (в значении, подобном
таковому в теории автоматов). При необходимости, в функциональном программировании
вся совокупность последовательных состояний вычислительного процесса представляется
явным образом, например, как список.
</pre> <h2><a class="anchor" id="autotoc_md64"></a>
Модель Отношений - это язык метапрограммирования.</h2>
<p><a href="https://ru.wikipedia.org/wiki/Метапрограммирование">https://ru.wikipedia.org/wiki/Метапрограммирование</a> </p><pre class="fragment">    Метапрограммирование — вид программирования, связанный с созданием программ,
которые порождают другие программы как результат своей работы (в частности,
на стадии компиляции их исходного кода), либо программ, которые меняют себя во
время выполнения (самомодифицирующийся код).
    Первое позволяет получать программы при меньших затратах времени и усилий на
кодирование, чем если бы программист писал их вручную целиком, второе позволяет
улучшить свойства кода (размер и быстродействие).
</pre><p> Модель Отношений в отличие от обычных языков программирования, основанных на линейно-текстовом представлении программы, основана на представлении программы в виде взаимосвязанного множества сущностей.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
Привести аналогию с ООП</h3>
<p>Модель Отношений относится к сущностно-ориентированному программирование, где сущность используется в качестве единственной фундаментальной концепции, т.е. предполагается, что всё есть сущность и нет ничего кроме сущностей.</p>
<p>В Модели Отношений, сущность в зависимости от своего внутреннего конститутивного принципа может быть либо структурой (объектом) либо функцией (методом). В отличае от известной ER - модели, где для представления схемы базы данных используются два базовых понятия — сущность и связь, в модели отношений и сущность и связь есть суть одно и тоже.</p>
<p>Сущность это элемент бинарного отношения, а связь (т.е. тип бинарной связи) есть относительный аспект сущности. Такое представление позволяет описывать не только внешние отношения сущности, но и внутреннюю её модель - модель отношений.</p>
<p>Сущность в своём внутреннем принципе триедина (троична, трёхэлементна), потому что она есть объединение (синтез) трёх аспектов (качеств) других (или себя) сущностей. Сущность может быть определена через 3 экземпляра отношений:</p><ol type="1">
<li>отношение субъекта</li>
<li>отношение отношения</li>
<li>отношение объекта Каждый из 3х аспектов (качеств) имеет своё значение и характеризует связанную сущность.</li>
</ol>
<p>Всего существует 3 типа связи:</p><ol type="1">
<li>с сущностью субъектом, т.е. сущностью выступающией в качестве субъекта</li>
<li>с сущностью отношением, т.е. сущностью выступающией в качестве бинарного направленного отношения между субъектом и объектом</li>
<li>с сущностью объектом, т.е. сущностью выступающией в качестве объект</li>
</ol>
<p><a href="https://ru.wikipedia.org/wiki/Бинарное_отношение">https://ru.wikipedia.org/wiki/Бинарное_отношение</a> </p><pre class="fragment">    Бина́рное (двухме́стное) отноше́ние — отношение между двумя множествами A и B,
то есть всякое подмножество декартова произведения этих множеств: R ⊆ A x B .
Бинарное отношение на множестве A — любое подмножество R ⊆ A² = A x A,
такие бинарные отношения наиболее часто используются в математике, в частности,
таковы равенство, неравенство, эквивалентность, отношение порядка.
</pre><p> В МО полагается, что внутренний конститутивный принцип конечного сущего реализается бинарным направленным отношением между двумя сущностями : сущностью - объектом и сущностью субъектом.</p>
<p>Таким образом каждая сущность есть экземпляр определённого отношения между определённым субъектом и определённым объектом.</p>
<p><a href="https://ru.wikipedia.org/wiki/Аспект">https://ru.wikipedia.org/wiki/Аспект</a> </p><pre class="fragment">Аспе́кт (от лат. aspectus «вид, облик; взгляд, точка зрения») — одна из сторон
рассматриваемого объекта, то, как он видится с определённой точки зрения.
</pre><p> Таким образом у сущности есть 3 аспекта (качеств), в которых она может выступать в других сущностях:</p>
<ol type="1">
<li>объект определяющий модель (Model)</li>
<li>субъект определяющий представление (View)</li>
<li>отношение определяющий контроллер (Controller)</li>
</ol>
<p>У каждого проявления качества сущности есть 3 важных параметра:</p>
<ol type="1">
<li>это сущность, которая проявляет качество, а именно: объекта, субъекта или отношения</li>
<li>это сущность, в которой проявляется одно из качеств другой сущности: модель, представление или контроллер</li>
<li>это сущность, характеризующая качество проявления: объективное, субъективное или качественное</li>
</ol>
<p>В объектно-ориентированном программировании аналог сущности это активный объект, который одновременно имеет собственное состояние и выполняет определённую функцию.</p>
<p>Как пишет Гради Буч в 3 главе: Классы и объекты </p><pre class="fragment">    Активный объект имеет свой поток управления, а пассивный - нет.
Активный объект в общем случае автономен, то есть он может проявлять свое поведение
без воздействия со стороны других объектов. Пассивный объект, напротив, может изменять
свое состояние только под воздействием других объектов. Таким образом, активные объекты
системы - источники управляющих воздействий. Если система имеет несколько потоков
управления, то и активных объектов может быть несколько. В последовательных системах
обычно в каждый момент времени существует только один активный объект, например, главное
окно, диспетчер которого ловит и обрабатывает все сообщения. В таком случае остальные
объекты пассивны: их поведение проявляется, когда к ним обращается активный объект.
В других видах последовательных архитектур (системы обработки транзакций) нет явного
центра активности, и управление распределено среди пассивных объектов системы.
</pre><p> В базе данных Модель Отношений хранится в виде ассоциативной модели данных.</p>
<p><a href="https://en.wikipedia.org/wiki/Associative_model_of_data">https://en.wikipedia.org/wiki/Associative_model_of_data</a> </p><pre class="fragment">    The associative model of data is a data model for database systems. Other data models,
such as the relational model and the object data model, are record-based. These models
involve encompassing attributes about a thing, such as a car, in a record structure.
Such attributes might be registration, colour, make, model, etc. In the associative model,
everything which has “discrete independent existence” is modeled as an entity, and
relationships between them are modeled as associations. The granularity at which data
is represented is similar to schemes presented by Chen (Entity-relationship model);
Bracchi, Paolini and Pelagatti (Binary Relations); and Senko (The Entity Set Model).
    A number of claims made about the model by Simon Williams, in his book
The Associative Model of Data, distinguish the associative model from more traditional models.
</pre><p> Модель Отношений обладает рефлексией, т.е. на МО возможно рефлексивно-ориентированное программирование.</p>
<p><a href="https://ru.wikipedia.org/wiki/Отражение_(программирование)">https://ru.wikipedia.org/wiki/Отражение_(программирование)</a> </p><pre class="fragment">    Рефлексивно-ориентированное программирование, или рефлексивное программирование
— функциональное расширение парадигмы объектно-ориентированного программирования.
Рефлексивно-ориентированное программирование включает в себя самопроверку, самомодификацию
и самоклонирование. Тем не менее, главное достоинство рефлексивно-ориентированной
парадигмы заключается в динамической модификации программы, которая может быть
определена и выполнена во время работы программы. Некоторые императивные подходы,
например, процедурная и объектно-ориентированная парадигмы программирования, указывают,
что существует четкая предопределённая последовательность операций обработки данных.
    Парадигма рефлексивно-ориентированного программирования, тем не менее, добавляет
возможность динамической модификации программных инструкций во время работы и их вызова
в модифицированном виде. То есть программная архитектура сама определяет,
что именно можно делать во время работы исходя из данных, сервисов и специфических операций.
</pre><p> Представление Модели Отношений в json обладает гомоиконичностью.</p>
<p><a href="https://ru.wikipedia.org/wiki/Гомоиконичность">https://ru.wikipedia.org/wiki/Гомоиконичность</a> </p><pre class="fragment">    Гомоикони́чность (гомоиконность, англ. homoiconicity, англ. homoiconic, от греч. ὁμός — равный,
одинаковый + «икони́чность» — отношение подобия между знаком и объектом, на который
данный знак указывает (см. семиотика) — в свою очередь, от ср.-греч. εἰκόνα — «о́браз»,
«изображение») — свойство некоторых языков программирования, в которых структура
программы похожа на его синтаксис, и поэтому внутреннее представление программы можно
определить, прочитав текстовую разметку. Если язык гомоиконичен, это означает,
что текст программы имеет такую же структуру, как её абстрактное синтаксическое дерево
(то есть AST и синтаксис являются изоморфными). Это позволяет всему коду на языке быть
доступным и обработанным в качестве данных, используя одно и то же представление.
    В гомоиконичном языке первичное представление программ является также структурой
данных в примитивном типе самого языка. Это делает метапрограммирование проще, чем
на языке без этого свойства, поскольку код может рассматриваться как данные: рефлексия
в языке (определение структуры программы во время выполнения) основана на единой,
однородной структуре, и не нужно обрабатывать несколько различных конструкций, которые
возникают в сложных синтаксических конструкциях. Говоря иначе, гомоиконичность — это когда
исходный код программы пишется как базовая структура данных и язык программирования знает,
как получить к ней доступ.
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
