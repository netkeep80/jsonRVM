<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="rmodel.files/filelist.xml">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>User</o:Author>
  <o:LastAuthor>User</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>32</o:TotalTime>
  <o:Created>2018-01-01T11:53:00Z</o:Created>
  <o:LastSaved>2018-01-01T12:25:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1331</o:Words>
  <o:Characters>7589</o:Characters>
  <o:Company>Microsoft</o:Company>
  <o:Lines>63</o:Lines>
  <o:Paragraphs>17</o:Paragraphs>
  <o:CharactersWithSpaces>8903</o:CharactersWithSpaces>
  <o:Version>11.9999</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p
	{font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>

<body lang=RU link=blue vlink=blue style='tab-interval:35.4pt'>

<div class=Section1>

<div>

<p><span lang=EN-US style='font-size:16.0pt;mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>         </span></span><span style='font-size:16.0pt'>Модель
Отношений<u1:p></u1:p></span></p>

<p>Модель Отношений – сокращённо МО, это язык <span class=SpellE>метапрограммирования</span>.
Модель Отношений в отличие от обычных языков программирования, основанных на
линейно-текстовом представлении программы, основана на представлении программы в
виде взаимосвязанного множества сущностей.</p>

<p>В своей основе МО, построена на двух главных концепциях: сущность и
отношение (связь).</p>

<p><i style='mso-bidi-font-style:normal'>Сущность</i> в МО <span class=GramE>представляет
из себя</span> экземпляр определённого <i style='mso-bidi-font-style:normal'>отношения</i>
между <i style='mso-bidi-font-style:normal'>субъектом</i> и <i
style='mso-bidi-font-style:normal'>объектом</i>.<span
style='mso-spacerun:yes'>  </span>Таким <span class=GramE>образом</span> каждая
сущность определяется тремя сущностями, каждая из которых выступает <i
style='mso-bidi-font-style:normal'>субъектом</i>, <i style='mso-bidi-font-style:
normal'>отношением</i> и <i style='mso-bidi-font-style:normal'>объектом</i>
соответственно.</p>

<p>Термины субъект, отношение и <span class=GramE>объект</span> употребляемые в
контексте МО означают аспект или качество в котором сущность выступает в
определённом экземпляре отношения. То, что сущность всегда <span class=GramE>определяется
через объединение 3-х качеств 3-х сущностей характеризует</span> её как
триединую. </p>

<p>Рассмотрим для лучшего понимания пример описания сущности на языке<span
class=GramE> С</span>++:</p>

<p><span class=GramE><span lang=EN-US style='mso-ansi-language:EN-US'>class</span></span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>Entity<u1:p></u1:p></span></p>

<p>{</p>

<u1:p></u1:p>

<p><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>Entity</span>* <span lang=EN-US
style='mso-ansi-language:EN-US'>Subject</span>;<span style='mso-tab-count:1'>         </span>\\
указатель на сущность выступающую в качестве субъекта для данной сущности</p>

<p><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>Entity</span>* <span lang=EN-US
style='mso-ansi-language:EN-US'>Relation</span>;<span style='mso-tab-count:
1'>        </span>\\ указатель на сущность выступающую в качестве отношения для
данной сущности</p>

<p><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>Entity</span>* <span lang=EN-US
style='mso-ansi-language:EN-US'>Object</span>;<span style='mso-tab-count:1'>           </span>\\
указатель на сущность выступающую в качестве объекта для данной сущности</p>

<p>};</p>

<p>Таким образом, весь концептуальный фундамент языка <span class=SpellE>метапрограммирования</span>
- Модели Отношений стоит из одной единственной и простой концепции триединой
сущности, в то время как в обычных процедурных и объектных языках
программирования в основе всегда лежит две противоположных концепции: Объект
(структура, данные, состояние) и Метод (процесс, процедура, функция,
алгоритм).<span style='mso-spacerun:yes'>  </span></p>

<p>Такое триединство сущности определяет МО как иерархическое пространство
взаимосвязанных триединых сущностей. Таким образом, и пространство, вмещающее
модель отношений тоже является иерархичным, потому что, каждая сущность
является системой состоящих из 3х подобных элементов: сущности субъекта,
сущности отношения и сущности объекта. В МО одновременно присутствует 3
иерархии: иерархия агрегирования (определяется через использование сущности в
качестве субъекта), иерархия типов отношений (определяется через использование сущности
в качестве отношения), иерархия использования (определяется через использование
сущности в качестве объекта).</p>

<p>Пространство, вмещающее модель отношений является нуль мерным, потому как у
сущностей нет неявного отношения порядка и направления расположения. Отношение
порядка явно определяется в модели отношений, таким образом, через сущности-отношения
можно определить любое N-мерное пространство.</p>

<p>Каждая сущность обладает уникальностью и должна обладать уникальным
идентификатором. При хранении в базе данных все сущности уникально нумеруются,
таким <span class=GramE>образом</span> отображение МО на таблицу БД получается
уже одномерным иерархическим.</p>

<p>В МО такие концепции, как данные и процесс есть два аспекта сущности.
Сущность можно либо прочитать – увидеть её проекцию (проявить для восприятия),
либо исполнить (активировать потоком управления её проекцию как сегмент кода),
в результате чего может измениться, как структура данных, так и структура
алгоритма.</p>

<p>В МО сохранение состояния сущности есть непрерывный процесс её существования,
обеспечивающийся <span class=SpellE>самоотображением</span> сущности, отображения
её состояния в самой себе. Это можно представить как процесс движения
информации о состоянии сущности по кругу (например, как в регистровой памяти
процессора). Конкретно это получается, если в своей структуре экземпляра отношения
сущность выступает как субъект.</p>

<p>При исполнении экземпляра отношения, т.е. триединой сущности, она
превращается в троицу <span lang=EN-US style='mso-ansi-language:EN-US'>MVC</span>
(<span lang=EN-US style='mso-ansi-language:EN-US'>Model</span>-<span
lang=EN-US style='mso-ansi-language:EN-US'>View</span>-<span lang=EN-US
style='mso-ansi-language:EN-US'>Controller</span>), т.е. сущность объект
выступает в качестве модели (что представляется), сущность субъект выступает в
качестве представления (куда проецируется), а сущность отношение выступает в
качестве контроллера (проекция сущности отношения исполняется как код виртуальной
машиной МО).</p>

<p><br>
Над сущностями в модели отношений можно производить всего только 2 операции:</p>

<p>1. Проецирование/Отображение (<span lang=EN-US style='mso-ansi-language:
EN-US'>View</span>) – включает в себя как бы 2 действия: чтение объекта и
изменение представления (шаблона) субъекта и/или модели отношений субъекта</p>

<p>2. Исполнение (<span class=SpellE>Exec</span>) - для определения
представления (шаблона) экземпляра отношения</p>

<p><br>
Операция записи является частным случаем проявления операции исполнения. Проекции
одних сущностей могут порождаться исполнением других.</p>

<p>В МО есть только сущности, но в зависимости от того через какое отношение
они определяются, они могут играть роль переменных, функций, методов, структур,
объектов, доменов значений, ссылок, шаблонов, лямбда структур и т.д.</p>

<p>Сама по себе МО трудна для непосредственного восприятия программистом,
поэтому программирование ведётся посредством оперирования в терминах
визуального представления сущностей предметной области.<br>
По сравнению с обычной программой модель отношений представляет собой гибрид
сегмента данных и кода, вернее более точным будет сказать единого семантически
неразделённого сегмента. Поэтому модель отношений исполняется посредством
самомодификации как полиморфный вирус. Программа на модели отношений может
меняться от запуска к запуску, таким образом, имея свою собственную жизнь.</p>

<p><br>
Программирование с использованием МО подразумевает совершенно иную концепцию
программирования – СОП (<span class=SpellE>сущностно</span> ориентированного
программирования), потому что модель отношений как таковая не требует стадии
компиляции и может исполняться параллельно с её программированием. Более того,
уже написанная программа на модели отношений, может в процессе своей жизни быть
многократно подвергнута изменению, перепрограммированию, через визуальное
программирование на основе представлений сущностей предметной области.</p>

<p><br>
Так же модель отношений нельзя отнести к процедурному или к объектному
программированию, потому что атомом модели отношений является сущность, которая
может выступать и как объект и как процедура. В МО нет классов как в ООП, там
есть только домены сущностей, причём домен появляется с первой <span
class=SpellE>доменнообразующей</span> сущностью. В МО используется клонирование
сущностей внутри домена. От любой сущности (кроме <span class=SpellE>доменообразующей</span>)
можно породить новый домен сущностей.</p>

<p><br>
Пример:</p>

<p>Entity10 (Entity10 -Entity10-&gt; Entity10<span class=GramE> )</span> - <span
class=SpellE>доменообразующая</span> сущность, она сама для себя является типом</p>

<p>Entity20 (Entity20 -Entity10-&gt; Entity20<span class=GramE> )</span> -
некая сущность входящая в домен Entity10</p>

<p>Entity30 (Entity30 -Entity20-&gt; Entity30<span class=GramE> )</span> -
некая сущность входящая в домен Entity20, таким образом сущность Entity20
теперь стала <span class=SpellE>доменообразующей</span>, но при этом сама не
входит в него!</p>

<p><br>
Примечание: для текстового представления простых МО используется несложный
текстовый псевдоязык (заметьте, что это всего лишь представление МО, но не её
первичная структура!!!).</p>

<p>В псевдоязыке сущности описываются следующим образом:</p>

<p>&lt;сущность&gt;( &lt;сущность субъект&gt; --&lt;сущность
отношение&gt;--&gt; &lt;сущность объект&gt;<span class=GramE> )</span></p>

<p>например: <span class=SpellE>a</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>global</span><span lang=EN-US> </span>-<span class=SpellE>int</span>-&gt;
<span class=SpellE>a</span><span class=GramE> )</span> - переменная а, входит в
состав агрегата <span lang=EN-US style='mso-ansi-language:EN-US'>global</span>,
входит в домен <span class=SpellE>int</span>, значением имеет саму себя (т.е.
не является ссылкой)</p>

<p>другой пример: <span class=SpellE>sum</span> <span class=GramE>( </span><span
class=SpellE>a</span> -<span class=SpellE>add</span>-&gt; <span class=SpellE>b</span>
) - сущность <span class=SpellE>sum</span> есть сумма а и <span class=SpellE>b</span>
(при чтении означает сумму, при исполнении возвращает результат суммирования)</p>

<p>Программирование с использованием модели отношений подразумевает в основном
два стереотипа:</p>

<p>1. <span class=GramE>В качестве основы будущей программы берётся дизайнер
модели отношений и посредством написания многоуровневых словарей сущностей
предметной области и сущностей представления сущностей предметной области
постепенно превращается в конечную программу, которая будет исполняться
виртуальной или аппаратной машиной модели отношений.</span> В данном варианте
программа может быть дописана <span class=GramE>пользователями</span> если
функция перепрограммирования не будет заблокирована разработчиками.</p>

<p>2. тоже <span class=GramE>самое</span> что и в 1 пункте но в конце
разработки генерируется исходный код программы на обычном языке
программирования, который в итоге компилируется и получается готовый продукт</p>

<p><br>
Замечательной особенностью модели отношений является то, что количество
сущностей в МО (модели отношений) есть точная метрика сложности программы.
Таким <span class=GramE>образом</span> при оптимизации модели отношений можно
точно определить степень оптимизации.</p>

<p><br>
Другой замечательной особенностью МО является отсутствие явной <span
class=SpellE>однопоточности</span> в исполнении, так как в ней нет линейности
при исполнении присущей линейно-текстовым языкам программирования. В МО там,
где не указано <span class=GramE>явно</span> что отношения должны искаться
последовательно они могут находиться параллельно. Поэтому виртуальная машина МО
может использовать то количество ядер в системе, которое есть в наличие.</p>

<p><br>
Так же в модели отношений можно делать автоматические эквивалентные
преобразования, что даёт путь к написанию сценариев автоматической оптимизации
программы. Например, поиск шаблонных участков МО для их выделения в отдельную
сущность и последующей заменой.</p>

<p>Если вас заинтересовал данный язык <span class=SpellE>метапрограммирования</span>,
пишите мне по адресу: <span lang=EN-US style='mso-ansi-language:EN-US'><a
href="mailto:netkeep80@gmail.com">netkeep<span lang=RU style='mso-ansi-language:
RU'>80@</span>gmail<span lang=RU style='mso-ansi-language:RU'>.</span>com</a></span><span
lang=EN-US> </span></p>

<p>Роман Павлович <span class=SpellE>Вертушкин</span><o:p></o:p></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u1:p>&nbsp;</u1:p></p>

</div>

</div>

</body>

</html>
