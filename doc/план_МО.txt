________________________________________________________________________________

	Фундаментальные вопросы

?. поток управления сущности, 1 поток на 1 сущность (нейросеть) или 1 поток на N сущностей (программа)
	Проверка условия (предиката) в программе эквивалентна изолированию результатов действий
	потоков управления по вычислению логической функции.
	Там где в логической схеме отбразывается значение логической функции, в программе этой функции не
	передаётся поток управления. Данный факт хорошо виден в графических ускорителях, где 
	проверка условий (предикатов) более затратна, чем отброс значения логической функции. Поэтому в них
	всегда вычисляется все логические функции, а потом отбрасывается не нужные результаты.

	При многопоточном исполнении всегда проще вычислять все логические функции, а потом 
	делать проверку результатов.

?. модульность (1 поток на 1 сущность) на 0 уровне мета программирования
?. идентификация экземпляров контекстов исполнения сущности
?. контекст исполнения сущности - экземпляра отношения - это её воплощение,
	он содержит отражения 3х аспектов сущности
?. сущность это процесс исполнения экземпляра отношения, этот процесс порождает проекцию
?. отношение проецирования исполняет объект во внешнем контексте используя субъект как локальную область видимости
?. только exec или exec + view 

________________________________________________________________________________
	Мысли

Время жизни сущности ограничено временем жизни контекста её исполнения.
Проекция сущности существует только в контексте её исполнения.
При исполнении сущности происходит её инстанцирование в контект исполнения.
Далее поток управления создает её проекцию, и пока поток управления находится в
контексте исполнения данной сущности, её проекция обновляется.

В общем случае для получения проекции сущности в языке целевой платформы, необходимо сначала получить
такой же тип проекции отношения данной сущности, а потом его исполнить
в контексте данной сущности.

Так как проекция сущности это отображение её МО, то по сути проекция это всегда МО.
Проекция может быть близка или далека от МО самой сущности, и могут быть использованы разныме
методы рефракции проекции в МО.

Проекция МО может быть удобной для модификации и доступа к её МО, а может быть не удобной,
например если это скомпилированный код.
json как проекция МО удобен тем, что это с одной стороны гибрид сигмента данных и кода,
а с другой стороны имеет иерахическую адресацию.

Фактически проекция сущности возникает и существует пока сущность инстанцирована в контексте
своего исполнения потоком управления. Время жизни проекции === время жизни сущности в контексте.
Пока сущность исполняется, её проекция в контексте изменяется.

Байткод это просто часть проекции сущности, в то время как вся проекция МО сущности это гибрид
сегмента кода и данных. Данные подразумевают адресацию, поэтому полная проекция МО сущности
это байткод + структура данных.

Для удобства рефлекции json проекции в МО должна быть возможность отображать триединые сущности в json
и/или иметь возможность адресоваться в МО из json.

Таким образом получается, что МО это суть проекции, полученная рефлекцией проекции,
 а проекция МО это представление МО, полученная проецированием.

Для получения проекции сущности необходимо исполнить в контексте данной сущности
проекцию её отношения.
Исполнение сущности это и есть получение её проекции, потому что проекция создаётся и обновляется
только в процесе исполнения сущности в контексте её исполнения.

Для исполнения проекции отношения сущности необходимо создать вложенный контекст исполнения
сущности отношения.

Отношение есть активный поток информации (от меня: от объекта к субъекту), чем этот поток больше,
тем ценнее отношение, при условии, что поток приводится в действие напряжением релевантности. (Джон Перри Барлоу)


	Существует 2 типа исполнения МО:

1. непосредственная интерпретация МО
1.1 json
1.2 bytecode
2. компиляция дерева МО через интерпретацию МО и проецирование в целевой язык и исполнение

________________________________________________________________________________

	Этапы

*. Анализ мыслей и планов по МО
*. Формат хранения документации с хэштегами в МО (с прицелом на модель знаний)
*. Переход на jsonpointer?
*. Поддержка адресации в БД и файлах (+удобство, -безопасность)
*. Разделение контекста на локальный и глобальный
*. 64битная сборка jsonRVM и их идентификация
*. Проверка производительности и возможностей JSONCONS (tags, refs and bytearrays)
	The jsoncons data model supports the familiar JSON types - nulls, booleans,
 numbers, strings, arrays, objects - plus byte strings. In addition, jsoncons supports
 semantic tagging of datetimes, epoch times, big integers, big decimals, big floats
 and binary encodings. This allows it to preserve these type semantics when parsing
 JSON-like data formats such as CBOR that have them.

*. Многопоточность в jsonRVM

*. План объединения jsonRVM + phpRVM

*.* Как хранить МО в SQL БД? (переход от хранения сущностей к хранению json МО)
*.* двунаправленный конвертор чистой МО <-> json для проверки корректности проецирования МО в json
*.* Переделать адресацию скомпилированных функций
*.* переделать PHPRVM по образу jsonRVM
*.*.* sub, rel, obj переделать на $sub, $rel, $obj
*.*.* вернуть код PHPView из БД в скрипт PHP
*.* шаблон мультиязыковой RVM (Обобщённый код виртуальной машины)

*.* На какой основе объединять? единый RVM bytecode или json как байткод?

*.* шаблоны проекции? сущности(модель сущности) и куда они проецируются (в контекст исполнения)
*.* RESTfull WebAPI

*. доделать калькулятор, что бы он работал на двух RVM
*. Иерархическая адресация в модели проекции объекта и субъекта транслируется в модель подготовки объекта и субъекта отношения
*. RMDesigner (на чем?, нужна многопоточность)

*. проекция МО в естественный язык
*. Формат хранения знаний в МО
*. обучение нейросетей на основе случайно сгенерированных МО
 Нейросеть на выходе выдает иерархический хэштэг сущности
*. нейросеть для распознавания МО в естественном языке
*. База знаний с языковым интерфейсом

*. pyRVM для нейросетей
*. ArduinoRVM для IOT
*. jsRVM для браузеров

*. проекция МО -> plantuml


________________________________________________________________________________
	Обобщенный код виртуальной машины

1.

________________________________________________________________________________
//                              ---Ближний план phpRVM---
//
//  1. доделать калькулятор...................................................5%
//  2. обновить сайт.........................................................50%
//
//  3. разобрать файл Rmodel.php что бы потом его удалить
//    * избавиться от класса Rmodel...........................................50%
//    * PHPExec.php   - exec RelId in EntId contex
//    * PHPDebug.php  - exec RelId in EntId contex (debug mode)
//
//  4. создать отображение REST WebAPI Entity.php:
//    * EntityGet    - view entity in json
//    * EntityPost   - edit entity
//    * EntityPut    - create entity in json
//    * EntityDelete - removes entity
//
//  5. сделать несколько простых примеров и проработать базовый словарь для этого:
//    * переменные и их конструкторы.........................................50%
//    * структуры
//    * ссылки...............................................................50%
//    * операции
//    * циклы
//    * конструкторы объектов
//
//  6. запихать весь возможный код в БД......................................33%
//  7. разобраться с хранением картинок в МО..................................0%
//  8. сделать 1-2 примера самомодифицирующихся моделей......................10%

//  * подумать над именами колонок в БД и переделать числовые идентификаторы в текстовые для распределения МО по сетевым узлам
//  * сделать генерацию EngView и RusView.....................................0%
//  * разграничить права, запуск и отображение только по паролю
//  * Flush all changes in Rmodel
//  * разграничение на проекты/хост-узлы?
//  * импорт/экспорт моделей/проектов/хост-узлов
//  * интеграция с PHP JSTP
//  * браузерная jsRVM (в качестве Йави использовать DOM)......................0%
//  * добавить в визуальные таблицы древовидное разворачивание структуры сущностей
//  * сделать добавление сущностей в древовидной структуре сущностей
//  * переделать на $EC........................................................0%
//   (Каждая сущность это одновременно шаблон структуры и шаблон программы по формированию этой структуры)
// 

////////////////////////////////////////////////////////////////////////////////
//                   ---Виды действий над сущностями---
//
//    2 функции - 2 базовых отношения:
//
//    1. Исполнение сущности:
// отвечает на вопрос: Как получить проекцию? exec() - исполняет проекцию сущности в контексте другой сущности,
// если проекции нет то создаёт её используя view()
//  это активация контроллера который должен спроецировать модель-объект в представление-субъект
//  исполнить можно только проекцию сущности в качестве контроллера в экземпляре отношения другой сущности
//  эта функция всегда вызывается для исполнения отношения Rel в экземпляре отношения $Ent
//  исполнится может только проекция отношения в текущий язык, т.е. $Ent['Rel']['PHPView']
//  Функция реализуется на целевой платформе
//
//    2. Отображение сущности:
// отвечает на вопрос: Куда спроецировать? view() - если в субъекте нет проекции то создаёт проекцию в нём,
// если проекции вообще нет то вызывает exec()
//  создать проекцию объекта в субъекте
//  делает конкатенацию к проекции субъекта
//  возвращает ссылку на созданную проекцию
//  Функция реализуется телом корневой сущности

//     PHPExec(): исполнение экземпляра отношения это создание или обновление проекции сущности
//  после обновления все кто использует данную сущность по ссылке будут использовать
//  обновлённый вариант проекции сущности
//  исполнение проекции контроллера в итоге должно изменить контекстную сущность $Ent и возможно агрегат $Ent['Sub']
/*
1. исполнение сущности это исполнение её PHPView в eval() который сначала надо получить
2. т.к. в итоге мы получаем определённую проекцию то в контекст eval надо передать предыдущее её состояние
3. после исполнения разумно закэшировать результат, что бы в след раз только обновить его

функция PHPExec() вызывается в следующих случаях:
1. извне для исполнения контроллера RelId в контексте EntId для получения результата проецирования
2. внутри самой себя для получения PHP проекции контроллера и получения проекции EntId
3. внутри закэшированнх тел сущностей базового словаря

Возможно в структурной проекции сущности разделить элементы и атрибуты:
1. элементов может быть много и одного типа, они составляют внутреннюю структуру сущности
 элементы формируются при участии данной сущности в качестве субъекта в других отношениях

2. атрибутов может быть только по 1 каждого типа, это проекции данной сущности
 атрибуты формируются при исполнении отношений в контексте данной сущности:
 $Ent[RelName] = PHPExec( RelId, EntId )

 Возможно атрибуты всего лишь поименованные ссылки на элементы!

 * проектор определяет метрику проекции, и в соответствии с этой метрикой располагает её в субъекте
 * у проектора PHPView метрика = 1

 * отношение всегда имеет уровень мета +1:
 1. если субъект и объект данные, то отношение есть программа
 2. если субъект и объект программа, то отношение есть генератор программы т.е. метапрограмма
 3. если субъект и объект метапрограмма, то отношение есть генератор метапрограммы т.е. метаметапрограмма
 и т.д.

 * адресация в метрике субъекта должна производиться контроллером
 * тип проекции которую создаёт контроллер по модели объекта зависит от контроллера,
 * адрес может определять как контроллер так и модель

 Пример контроллера проецирующего точку:
{
 $PHPView = &$Ent['Obj']['Color'];
 $Ent['Sub'][ $Ent['Obj']['x'] ][ $Ent['Obj']['y'] ] = &$PHPView;
}
 Этот код будет исполнен в eval() при вызове PHPExec( PointIdXXXX, 0 );

 В общем случае PHPView может быть сложным иерархическим объектом, надо решить как его исполнять?
 Как то сериализовывать в сплошной код, либо усложнить исполнитель - виртуальную машину.

 если сущность есть замкнутая структура, то её проекция должна иметь замыкание с именем её отношения
*/
________________________________________________________________________________

У сущности есть 3 возможных качества в которых она может быть проявлена в других сущностях:
1. объект определяющий модель
2. субъект определяющий представление
3. отношение определяющий контроллер

У каждого проявления качества есть 3 определяющих параметра:
1. сущность, которая проявляет качество:       объекта ,    субъекта   , отношения
2. сущность, в которой проявляется одно из качеств другой сущности: модель  , представление , контроллер
3. сущность, характеризующая качество проявления: объективное, субъективное, качественное


________________________________________________________________________________

	Словарь

сущность
объект
субъект
отношение
модель
представление
контроллер
качество
проявление
определять

-----------------------------------------------------------------------------------------------------------------

Немного описания содержится в комментариях в файле jsonRVM.h

jsonRVM это виртуальная машина для интерпретации проекции языка метапрограммирования Модели Отношений. Почему проекции, потому что сама по себе Модель Отношений (далее МО) это именно модель типа UML, и в чистом виде может храниться только структуре типа таблицы базы данных.

Предыдущей реализацией RVM была серверная PHPRVM, но для неё МО приходилось создавать вручную прописыванием строк в таблице БД. Это было очень медленно и неудобно. Некоторое время назад на работе понадобилось создать инфраструктуру тестирования WebAPI облачного сервиса, вот так и родилась идея создать jsonRVM для непосредственной интерпретации проекции МО в json.

Теперь объясню попроще, что это и как работает и как например это можно было бы применить в игрострое.

В современном мире json постепенно из простого формата сериализации превратился в нечто большее, можно сказать в универсальный формат описания и представления любых данных. Большая часть трафика интернета это именно json. Уже даже многие реляционные базы данных поддерживают работу с json в запросах SQL. json используют в конфигах, в описаниях GUI и т.д.

НО нет возможности каким либо образом написать алгоритмы на самом json, ведь это формат описания данных, а не логики. Тут только остаётся вариант прикрутить какой нибудь легковесный js интерпретатор, ну либо вообще писать игру на js.
И вот тут то как раз хорошо в json формат мэппится МО, потому что МО это модель взаимосвязей сущностей, а значит представляет из себя данные. В обычных языках программирования всегда есть четкое разделение на данные и алгоритмы, на сегмент данных и сегмент кода. А вот МО является как бы одновреименно и кодом и данными, потому что это Сущностно-Ориентированное Программирование.

Каждая сущность в МО это аналог активного объекта в ООП, т.е. это экземпляр объекта обладающего и состоянием и потоком управления, исполняющим некий метод этого объекта.

Теперь ближе к делу, как именно это всё реализуется в json.
Для хранения описания сущностей в json, был искуственно введён новый тип узла в дереве данных json, т.е. кроме типов null, integer, float, string, object и array добавлен тип entity. С точки зрения json это обычный узел типа json объект, но у него есть как минимум поле с именем $rel определяющее сущность-отношение. По этому признаку jsonRVM определяет, что это не просто json данные, а именно сущность, и интерпретировать её надо по другому. Кроме поля $rel, сущность опционально содержит поля $obj и $sub, а так же может содержать поля с различными внутренними атрибутами сущности.

jsonRVM может воспринимать json по разному, либо как просто данные либо как проекцию МО которую надо исполнить. На вход jsonRVM всегда передаётся проекция МО корневой сущности, которую необходимо исполнить, т.е. найти её представление.
Каждая сущность в МО это экземпляр отношения между двумя сущностями: субъектом и объектом. Тут важно не путать понятие с объектом из ООП. В МО используется понятие объекта именно в философском смысле.

Приведу на всякий случай определения из вики:
	Объе?кт (лат. objectum «предмет») — философская категория, обозначающая вещь,
явление или процесс, на которые направлена предметно-практическая, управляющая
и познавательная деятельность субъекта (наблюдателя); при этом, в качестве
объекта может выступать и сам субъект. Субъектом может быть личность,
социальная группа или всё общество.

	Субъе?кт (лат. subjectum «лежащее внизу; находящееся в основе») — носитель
деятельности, сознания и познания[1]; индивид, познающий внешний мир (объект)
и воздействующий на него в своей практической деятельности; человек или
консолидированная группа лиц (напр., научное сообщество), общество, культура
или даже человечество в целом, противопоставляемые познаваемым или
преобразуемым объектам[2].

Если смотреть с точки зрения ООП то и объект и субъект в принципе будут объектами.

С точки зрения исполнения сущностей, т.е. экземпляров отношений, каждую сущность можно понимать как троицу MVC:
Model = object
View = subject
Controller = relation

В экземпляре отношения в качестве объекта, субъекта и отношения выступают тоже такие же сущности,
поэтому MVC превращается в тройное дерево, а шаблон уже будет называться 
ScMHMVC (Self-compiled Multi-layered Hierarchical Model View Controller).
Практически это означает, что объектом может выступать результат проецирования из другого слоя MVC,
субъектом может являться элемент дерева MVC, а контроллером результат исполнения другой экземпляр троицы MVC,
либо представление и другой троицы MVC.

Но это всё довольно сложно, и возможно не обязательно понимать для того того что бы начать что то писать на json МО.

Разберём простенький пример из каталога test, а именно version.json:
{
   "$rel" : [
      {
         "$obj" : "#/RVM_version",
         "$rel" : "#/=",
         "$sub" : "/RVM_version"
      },
      {
         "/meta" : "#/json/meta"
      }
   ]
}

Для исполнения этой модели необходимо запустить в командной строке:
jsonRVM.exe version.json

Что мы тут видим, корневой сущностью является искусственно введённый в json узел entity
(это json object с полем $rel), значит это именно сущность МО которую необходимо интерпретировать,
и для этого надо создать новый контекст исполнения. Отсутствие полей $obj и $sub говорит о том, что они топологически замкнуты
на саму это корневую сущность, а значит в контексте исполнения будут указывать и результат проецирования корневой сущности.
Отношением у этой сущности выступает json array,
а это значит, что это pipeline из сущностей (или их проекций в json) которые необходимо последовательно исполнить.
Первой сущностью в pipeline является узел json entity, т.е. надо создать вложенный контекст исполнения для исполнения этой сущности. У неё заданы все поля $obj, $rel, $sub, т.е. у сущности отсутствуют топологические замыкания на саму себя.
Если в полях $obj, $rel, $sub находится строка то это ссылка по аналогии со стандартной $ref, где # указывает на корень json документа, в нашем случае проекция МО корневой сущности.

Семантика json значений в полях "$sub", "$rel", "$obj" json объекта описывающего сущность:

1. Number  - адрес json объекта в памяти
2. Boolean - непосредственное значение = true/false
3. String  - иерархический путь к сущности относительно текущего контекста исполнения
4. Object  - json объект определяющий непосредственное значение сущности
5. Array   - json массив определяющий непосредственное значение сущности
6. Null    - значение по умолчанию, пустой указатель на сущность обозначающий топологическая замкнутость на текущую проекцию сущности в контексте исполнения EV[""]
7. Entity  - непосредственное описание другой сущности

Перед тем как рассказывать далее надо сделать небольшое отступление.
Дело в том, что для нормальной работы RVM нужен хотя бы минимальный базовый словарь сущностей.
Прямо в jsonRVM.exe закомпилен базовый словарь сущностей, а так же версия RVM которая была использована при компиляции словаря.
Для просмотра этого словаря необходимо в качестве аргумента при запуске jsonRVM.exe передать саму jsonRVM.exe, т.е. запустить в командной строке: jsonRVM.exe jsonRVM.exe

После парсинга version.json виртуальная машина автоматически догружает в корневую сущность базовый словарь сущностей, что бы 
была возможность дальнейшего исполнения МО корневой сущности.

Разберём конкретные значения:
{
  "$obj" : "#/RVM_version",  - указатель на версию базового словаря сущностей
  "$rel" : "#/=",            - указатель на сущность идентичного проецирования, т.е. присваивания
  "$sub" : "/RVM_version"   - указатель на свойство RVM_version в локальной области видимости текущего контекста исполнения
}

Локальной области видимости это такой же json узел, явно заданный при исполнении сущности. Аналогом является локальная область видимости при исполнении метода класса, обычно размещается на стэке процессора.

Для корневой сущности локальная область видимости это результат исполнения МО корневой сущности, это именно то что jsonRVM в конце исполнения выводит в консоль.

Второй сущностью исполняемой в pipeline будет json object
{
  "/meta" : "#/json/meta" - компактная запись отношения проецирования объекта в субъект
}

Вот пояснение по исполнению json значений:
Семантика json значений при исполнении  (json как байткод RVM):

1. Number  - адрес скомпилированного тела сущности, которое необходимо исполнить RVM
2. Boolean - true : спроецировать / false : не проецировать объект в субъект
3. String  - иерархический путь к json значению относительно контекста исполнения,
				которое необходимо исполнить RVM
4. Object  - множество пар "имя поля": значение поля, где
			значение поля - иерархический путь к json значению относительно контекста исполнения, которое необходимо исполнить
			имя поля - иерархический путь к json значению относительно контекста исполнения, куда необходимо спроецировать сущность
			вычисление проекций множества пар может происходить параллельно, в многопоточном режиме
5. Array   - массив значений json которые необходимо последовательность исполнить
				в текущем контексте исполнения, при этом результат предыдущего
				исполнения всегда доступен для следующей исполняющейся сущности
6. Null    - возврат текущей контекстной проекции в саму себя, т.е. по сути отсутствие действия над текущей проекцией в контексте исполнения
7. Entity  - сущность, для которой надо создать дочерний контекст и исполнить

В итоге свойство #/json/meta будет записано в свойство meta локальной области видимости.
Ну вот как то так. А вообще сущностно-ориентированное программирование вот так в 2х словах не объяснить, потому что это более фундаментальная концепция по сравнению с процедурным программированием или ООП.


