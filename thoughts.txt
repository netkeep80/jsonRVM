 #RVM/exec
 В контексте определённой виртуальной машины МО исполнение возможно только на её байткоде.
 У любой ВМ есть 2 варианта исполнения:
 1. компиляция и исполнение непосредственно в её байткоде
 2. интерпретацию сущностей не имеющих проекцию в байткод данной ВМ

 #RVM/exec
 Исполнение сущности это последовательное проецирование (компиляция) её нульмерной структуры
  в контекст исполнения и её исполнение потоком управления.
 Для избежания лишних расходов ресурсов проекция может быть закэшированна.
контекст исполнения есть модель.
 Проекция сущности это шаблон контекста её исполнения.

Элементарной операцией виртуальной машины должна быть операция проецирования.
Контекст исполнения это проекция.

Положительные индексы указывают в пространство Навь.
Отрицательные индексы указывают на относительную адресацию в пространстве контекста
 (пространство - Правь).
Результат исполнения в сознании - Явь.

Экземпляр отношения это проекция сущности в модель отношений (проектор void[id==0]),
 т.е. допустим есть экземпляр отношения:
 _________________________________
 | EntID | SubID | RelID | ObjID |
 ---------------------------------
 |   0   |   1   |   2   |   3   |
 ---------------------------------

 тогда он будет храниться в кэше проекций в следующем виде:
 ___________________________
 | EntID | ViewID |
    ent     ent 

при исполнении entity( entity --entity-> entity ) должен произойти прыжок в контекстную сущность,
 т.е. возврат.

Начало исполнения:
1. загрузка в сознание первой цифры - это указатель на адрес возврата = родительский контекст
 (возможно надо эту цифру сделать последней, что бы зря её не держать во внимании,
  а сразу использовать при загрузке)
2. 

OISC_RVM компилирует проекции сущностей и управляет компиляцией проекций сущностей,
 используя для этого единственную инструкцию.
(чистое движение это проецирование в другую точку пространства)

/////////////////////////// old ///////////////////////////////////////////////////////////
		План:

1. сделать сегмент данных для МО - json  .........................................V
2. сделать управление свободными сущностями в МО
3. доделать аллокатор памяти
4. додумать упаковку последовательностей структуры сущностей
5. сделать проект RM_Loader.dll  .................................................V
6. сделать библиотеку базовых сущностей виртуальной машины rm_basevoc.dll.........V
7. сделать проект генерации тестовой МО rm_test1.exe
8.
9. парсер псевдоязыка json .......................................................V

 CristalPro2 ???
1. перенести функции в сущности
2. переделать под изменённую архитектуру
3. разработать архитектуру библиотеки графических контролов

При загрузке библиотека будет запускать виртуальную машину

	Состав сущностей:
1. InitGUI( NOENT, Entity )
2. FreeGUI( NOENT, Entity )
3. BindController( ParentController, Model )
4. UnbindController( ParentController, Model )
5. Yield( NOENT, RVM16 )
6. ShowMessageBox( Title, Message )
7. OnChangeSubject( Controller, Entity )
8. OnChangeRelation( Controller, Entity )
9. OnChangeSubject( Controller, Entity )

Каждый контроллер подписывается на уведомления об изменении отображаемой сущности
 ко всем контроллерам в иерархии контроллеров отображающих ту же сущность
 
Каждый контроллер описывает какую сущность где и как он отображает
Сущность CreateView это МО инициализирующая иерархию контроллеров
 привязанных к конкретным сущностям в иерархии МО отображаемой сущности
 
 Получается что когда создаётся контроллер (или обновляется) то должны проинициализироваться свойства
  View для которой он создаётся
  
контроллер изменяет в графическом контроле свойства

Для отображения конкретной сущности необходимо:
1. клонировать модель конкретной view для которой существует графический контрол в бибилиотеке
2. задать значения её аттрибутов (например для SLE это x, y, text, width, height, visible, enabled ...)


1. Акт отображения есть действие, т.е. исполнение МО, поэтому в этот момент доступен контекст
2. для графического контрола акт отображение есть его отрисовка в первый раз либо перерисовка
3. для потокового коллектора акт отображения есть его первый либо последующий вывод потока
4. модель View не содержит реакций
5. контроллер активирует View, т.е. запускает или перезапускает отображение
6. в иерархическом графическом View может быть частичное обновление,
  но Controller должен знать какую часть обновлять
7. в иерархическом потоковом коллекторе может быть частичное обновление, 
  но Controller должен знать позицию в потоке
8. Изменения в View: добавление атрибута (INSERT), изменение атрибута (UPDATE), удаление атрибута (DELETE)
9. Отображение View есть операция чтения аттрибута (SELECT)
10. (Пере)Отображение View происходит при операции SELECT и операциях INSERT, UPDATE, DELETE в дочерних View
11.	Создание контроллера при операции INSERT (INSERT в BPVM для рута)
12.	Удаление контроллера при операции DELETE (DELETE из BPVM для рута)
13. время жизни модели View соответсвует необходимости его присутствия в модели для отображения части МО
14. время жизни контроллера соответсвует времени в течении которого на экране видно View
 (видимая иерархия View та у которой рутом является действующая PBVM, для этой иерархии созданы контроллеры),
  либо времени в течении которого идет работа с потоком

       Кто управляет временем жизни контроллера?
1.  Очевидно что МО View не может управлять временем жизни своего контроллера.
2. при некоторых изменениях в МО View дочерние контроллеры могу уничтожаться, но опять
 же эти изменения есть обработка событий вышестоящим контроллером
3. если контроллер ассоциирован 1 к 1 со своей View то знания о том как обрабатывать события
 он может взять только из МО View
4. Создание и уничтожение контроллера для МО View есть внешняя операция над МО View,
 эту операция производит либо просто некая сущность либо родительский контроллер
5. Операция создания контроллера и отображение View есть разные вещи
6. Для запуска отображения некой сущности необходимо вызвать событие SELECT в соответствующем контроллере
7. можно первым делом после конструктора контроллера что бы он сам сразу вызывал у себя событие SELECT
которое приведёт к генерированию всей вложенной иерархии контроллеров у МО View


1. Yield() это SELECT (refresh) у рута т.е. PBVM 
 (но вообще не стоит привязываться к библиотекозависимым именам)
2. создание МО View и разработка View это разные вещи
3. в МО View есть только 2 типа отношений: VOID и VIEW
  VOID описывает структуру иерархии
  VIEW указывает кто кого отображает
4. МО View может использовать местоимения:
   ENT для доступа к сущности-ЭО отображения использующую данную МО View, что эквивалентно её контроллеру
   SUB для доступа к самой себе ~ this,
   REL = VIEW,
   OBJ для доступа к сущности отображаемой данной МО View
5. обновление View идёт всегда в контексте вышестоящего отнощения отображения
6. получается что одна МО View может использоваться для отображения немкольких сущностей в разных
  отношениях отображения
7. МО View должна иметь в себе доступ к контроллеру через GetParentController 


Стандартный набор сущностей библиотеки GUI (при подгрузке DLL автоматически запускается PBVM):
1. CreateGUI (создание корневого контроллера GUI)
2. DestroyGUI (создание корневого контроллера GUI)
3. DispatchGUIEvents (обработка событий GUI)
4. View (сущность отношения отображения)
5. GetParentController ( RetVal, идентификатор экземпляра отношения View )
  возвращается родительская сущность-ЭО отображения, в которой есть родительская View
   и родительская отображаемая МО
 
Расширенный набор:
1. MessageBox( TitleEntityID, MessageEntityID ) - отображения диалогового сообщения
2. OnChangeName( GUI, Entity ) - сообщение контроллеру View что изменилось имя сущности
3. OnChangeEntity( GUI, Entity ) - сообщение контроллеру View что изменился состав сущности
4. OnChangeSubject( GUI, Entity ) - сообщение контроллеру View что изменился субъект в сущности
5. OnChangeRelation( GUI, Entity ) - сообщение контроллеру View что изменилось отношение в сущности
6. OnChangeSubject( GUI, Entity ) - сообщение контроллеру View что изменился объект в сущности

1. Корневой контроллер GUI управляет приложением которое может создавать множество окон 
2. Корневой контроллер GUI хранит карту взаимосвязей контроллеров и сущностей, что бы быстро 
определять какой контроллер требует обновления при изменении той или иной сущности

1. непонятно как контроллер будет определять изменения в МО View...

rm_pbgui.dll -> PBVM.dll -> rm_pbgui.pbl-\
      \__________________________________|
      
 С обновлением во вьюшках сущностей которые непосредственно отображаются проблем проблем нет,
 а вот с сущностями которые входят в состав МО результат который отображается, всё усложняется.
 Поэтому для таких случаев наобходимо использовать потоковые коллекторы, которые будут являться
 отображениями МО результат которых отображается через графические вьюшки. Иерархия потоковых
 коллекторов фактичеки реализует модель прямого исполнения в МО. Таким образом универсальное 
 правило для правильного обновления интерфейса пользователя следующее: контроллер изменяющий
 некую сущность должен уведомлять контроллеры отображающие эту сущность. Контроллер отображаемая
 сущность которого изменилась должен уведомить родительский контроллер о том что надо обновиться.
 
 /////////////////
1. RVMLib.dll реализует RVM, может вызывать callback'и при изменении сущностей,
 при может использоваться любыми языками и подгружать словари для 
 любых графических библиотек, в том числе PB_GUI.dll

2. PB_GUI.dll написана на С++, она инициализирует работу виртуальной машины PowerBuilder
 (в случае если нет созданной сессии, либо использует переданную сессию)
 предоставляет словарь работы для создания и удаления визуальных контролов, а так же
 обрабатывает в цикле события возникающие в GUI (через простое отношение Yield выясняемое в цикле)

3. PB_GUI.pbl(pbd) - библиотека визульных контролов

4. RVMLib.pbd интерфейс для RVMLib.pbx

5. RVMLib.pbx объектная библиотека-обёртка для предоставления доступа к RVMLib.dll
 регистрирует callback'и в RVMLib.dll для генерации событий изменения сущностей
 (объекты: uo_rmodel (хранит МО, исполняет МО, генерит события при изменении сущностей МО), )
///////////////////



надо разработать формат модели отношений который бы удовлетворял следующим требованиям:
1. значение на стеке не должно иметь идентификатор сущности (он есть в контексте!)
2. минимум косвенности при доступе к значениям
3. общность форматов BRM и формата хранения МО в БД
4. поддержка работы PowerBuilder
4. при ресайзе МО не надо перегенерировать указатели на значения
5. размер сущности и выравнивание сущностей в памяти равно 16 байт?
6. кучность МО для возможности кэширования
7. МО не должна меняться при реаллоке какого либо массива данных


a ( U8 -STRING-> -123 )
b ( a -INDEX-> +1 ) // в элементах


1. если в МО есть свободная сущность то доступ к ней есть исключительная ситуация, т.к. содержание её полей недетерминированно
2. исходя из этого информация о использовании сущностей должна храниться вне сущностей.
3. на местах свободных сущностей можно хранить данные значений
4. информацию о размерах последовательностей значений можно хранить вне модели, 
  эта информация не требует минимизации косвенности т.к. требуется только для строковых операций, где это не критично
5. Необходимо завести массив структур описывающих место в памяти, занимаемое сущностями,
5.1 этот массив должен быть вне пространства МО
5.2 этот массив должен так же храниться в БД (отдельная таблица, либо доп. поля в таблице сущностей!)
6. неиспользуемые фущности можно форматировать соотвествующим образом, что бы можно было их бысто найти в МО,
  а так же востанавливать массив структур описывающих место в памяти?


 u8 ( u8 -domain-> -20 )

  a ( u8 -value-> -10 )

  b ( a -value-> -4 )


хранить или не хранить исполняемые тела сущьностей в BRM ?
с точки зрения платформенной независимости надо хранить всё раздельно,
МО в BRM а словари исполняемых тел в DLL для соответствующей платформы

тогда система исполнения МО включает следующие компоненты
1. платформозависимый загрузчик BRM, с минимальным набором встроенных тел (тела: NOENT, VOID(интерпретатор), VALUE, HAS, LOADDLL, LOADENT)
	при загрузке BRM, сбрасывает указатели на тела всех сущностей

2. файлы бинарным моделей отношений BRM 
3. файлы текстовых моделей отношений
4. файлы моделей отношений ввиде XML
5. платформозависимые DLL с исполнимыми телами словарных сущностей
