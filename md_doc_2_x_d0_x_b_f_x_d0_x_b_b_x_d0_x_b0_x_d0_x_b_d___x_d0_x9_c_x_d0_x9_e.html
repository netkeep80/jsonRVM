<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsonRVM: План развития МО</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="rm_view.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">jsonRVM
   </div>
   <div id="projectbrief">json Relations (Model) Virtual Machine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_2_x_d0_x_b_f_x_d0_x_b_b_x_d0_x_b0_x_d0_x_b_d___x_d0_x9_c_x_d0_x9_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">План развития МО</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
1. Понятийный словарь</h1>
<h1><a class="anchor" id="autotoc_md2"></a>
2. Введение в МО</h1>
<h1><a class="anchor" id="autotoc_md3"></a>
3. Цели и задачи МО</h1>
<h1><a class="anchor" id="autotoc_md4"></a>
Базовые сущности МО</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
0. ent = &lt;sub, rel, obj&gt;</h2>
<p>!Сущность есть субъективное отношение объекта!</p>
<p>Ent { Rel = Obj / Sub }</p>
<p>Абсолютное отношение осуществления - есть процесс в результате которого отношение выступает в качестве сущности. Осуществление - причинно-следственный переход, следование от одного к другому, бытие существования отношения. Сущность - отношение объекта в субъект??? Благодаря своей сущности конечное сущее выделяется как относительное из абсолютного, как конечное из бесконечного бытия. Т.к. абсолютное отношение - осуществление объекта в субъекте т.е. сущность это то что относительно в абсолютном т.е. сущность отношения в абсолютном отношении </p><pre class="fragment">'rel()' - as ent - осуществление / способ движения в отношении / относительное движение
Осуществление отвечает на вопрос каким образом

ent()
</pre><p> Поведение при исполнении в качестве сущности:</p>
<p>Символ для обозначения осуществления: ':'</p>
<h2><a class="anchor" id="autotoc_md6"></a>
1. rel = { sub, ent, obj }</h2>
<p>!Отношение есть субъективное осуществление объекта!</p>
<p>Абсолютное отношение определяет само себя через другие абсолютные отношения как осуществление субъективации объективации, тем самым потенциирует МО. Кратко отношение - осуществление (т.е. бытие существования) субъективации объективации. Отношение - осуществление объекта в субъекте? Сущность – это снятое бытие. Снятие – отрицание с удержанием.</p>
<p>Абсолютное отношение триедино, как постоянный процесс перехода единства в тройку и назад. </p><pre class="fragment">    rel = sub(obj(rel))
    ent(rel) = sub(obj(rel))
ent(rel) = rel(e) == sub(obj(e))

rel. = obj(rel) = { sub, ent, obj } - чистое бытие по Гегелю
sub(rel) = 
ent(rel) = exec(sub, ent, obj)
rel(rel) = rel 

rel() = {}
</pre><p> Поведение при исполнении в качестве сущности: Абсолютное отношение как процесс - создание нового отношения как результат осуществления субъективации объективации в состояние отношения записывается идентификатор сущности r0 = { obj, rel(), sub } r1 = { r2, rel, r3 }</p>
<p>Символ для обозначения абсолютного отношения: ',' в json, '' в строках</p>
<p>РВМ процесс порождающий МО из абсолютного отношения. РВМ процесс порождения бытия из потенции абсолютного отношения.</p>
<p>Каждое отношение имеет 3 относительных аспекта и один абсолютный. Три относительных аспекта определяют координаты в относительном адресном пространстве МО, а абсолютный аспект определяет содержимое координат.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
1. sub =  = { ent, rel, obj }</h2>
<p>Абсолютное отношение субъективации - есть процесс в результате которого отношение выступает в качестве субъекта. Кратко субъективация - переход от отношения к сущности. Субъективация - отношение объекта к сущности. Анализ - получение относительного из абсолютного. </p><pre class="fragment">'rel &lt;&lt;' - as sub - субъективация / восприятие внутрь / относительное поглащение 
Субъективация отвечает на вопрос куда

sub()
</pre><p> Поведение при исполнении в качестве сущности:</p>
<p>Символ для обозначения субъективации: '$'</p>
<h2><a class="anchor" id="autotoc_md8"></a>
01. obj</h2>
<p>Абсолютное отношение объективации - есть процесс в результате которого отношение выступает в качестве объекта. Объективация или явление (гл.) - переход от сущности к явлению (сущ.). Объективация рождает объект. Объективация - отношение сущности к объекту. Синтез - получение абсолютного из относительного. </p><pre class="fragment">'&lt;&lt; rel' - as obj - объективация / проектирование наружу / относительное излучение
Объективация отвечает на вопрос откуда

obj(rel()) = { sub, ent, obj }
</pre><p> Поведение при исполнении в качестве сущности:</p>
<p>Символ для обозначения объективации: '.'</p>
<p>a = b.c; rel = sub.obj</p>
<pre class="fragment">3 Абсолютных отношения в МО: ???
</pre><ol type="1">
<li>rel.sub / Абсолютное отношение субъекта отношения - процесс доступа к субъекту</li>
<li>rel.ent / Абсолютное отношение сущности отношения - процесс доступа к сущности</li>
<li>rel.obj / Абсолютное отношение объекта отношения - процесс доступа к объекту</li>
</ol>
<pre class="fragment">9 Относительных подпроцессов в МО (+12 базовых отношений в Модели Отношений):
</pre><ol type="1">
<li>Субъективация субъекта - ? подстановка местоимения</li>
<li>Субъективация сущности - создание нового контекста исполнения</li>
<li>Субъективация объекта - проявление объекта в субъекте (типичный MVC)</li>
<li>Осуществление субъекта - ? отношение следования, т.е. лямбда вектор</li>
<li>Осуществление сущности - исполнение сущности в контексте</li>
<li>Осуществление объекта - отдельная пара в лямбда структуре</li>
<li>Объективация субъекта - запись субъекта отношения в текущем состоянии отношения</li>
<li>Объективация сущности - запись сущности отношения в текущем состоянии отношения</li>
<li>Объективация объекта - запись объекта отношения в текущем состоянии отношения</li>
</ol>
<p>struct rel { rel&amp; sub; rel&amp; ent; rel&amp; obj;</p>
<p>rel() : sub(*this), ent(*this), obj(*this) {} rel(rel&amp; s, rel&amp; e, rel&amp; o) : sub(s), ent(e), obj(o) {} } $rel, $sub, $ent, $obj;</p>
<p>rel a, b, c; rel r1{ a, b, c };</p>
<p>rel r1_sub{ r1, $sub, a }; rel r1_ent{ r1, $ent, b }; rel r1_obj{ r1, $obj, c };</p>
<p>rel r2{ r1_sub, r1_ent, r1_obj }; </p><pre class="fragment">/-&gt; r1.sub -&gt; a -&gt; as sub -\
</pre><p> r1--&gt; r1.ent -&gt; b -&gt; as ent --&gt; r2 -&gt; r1.obj -&gt; c -&gt; as obj -/</p>
<p>a -&gt; as sub -\ /-&gt; r1.sub b -&gt; as ent --&gt; r1--&gt; r1.ent c -&gt; as obj -/ -&gt; r1.obj</p>
<p>С точки зрения РВМ субъект отношения есть операция доступа к качеству субъекта отношения. С точки зрения РВМ объект отношения есть операция доступа к качеству объекта отношения. С точки зрения РВМ сущность отношения есть операция доступа к качеству сущности отношения. Операция над отношениями может быть 3х видов:</p><ul>
<li>субъективация (чтение МО с т.з. РВМ)</li>
<li>объективация (запись МО с т.з. РВМ)</li>
<li>осуществление (исполнение МО с т.з. РВМ)</li>
</ul>
<p>Субъект и Объект есть процесс Сущность отношения - отрицание отношения - не процесс - принцип взаимодействия субъекта и объекта в отношении Сущность отношение - есть суть отношения Исполнение != проявление</p>
<p>Проявление это про</p>
<p>Отношение есть объект (триплет) Отношение есть процесс (проявление сущности) Отношение есть субъект (хранилище состояния) Отношение не есть сущность отношения (триплет)</p>
<p>Сущность Субъект и Объект это качество использования отношения 1 это результат субъективации отношения</p>
<p>Абсолютное понятие: Отношение есть совокупность трех взаимосвязанных отношений: объекта отношения, субъекта отношения и сущности отношения. Не определяя его отношений мы не можем работать с его абсолютным. Отношение есть абсолютное триединство своих относительностей.</p>
<p>Отношение может выступать в трех различных качествах Качества Объекта отношения - есть отношение выступающее в роли объекта в отношении Качества Субъекта отношения - есть отношение выступающее в роли субъекта в отношении Качества Сущности отношения - есть отношение в роли действия в отношении Само отношение без рассмотрения его качеств есть абсолютное понятие. Не определяя качества отношения мы не можем с ним работать.</p>
<p>Результат Состояние отношения - есть Результат отношения - есть итоговое состояние отношения</p>
<p>Самодостаточное отношение - есть отношение в котором все его отношения выражены через себя, т.е. полностью определённое самого через себя.</p>
<div class="fragment"><div class="line">&quot;1+2&quot; = + ( 1, 2 )</div>
<div class="line"> </div>
<div class="line">&quot;sub of 1+2&quot; = sub( &quot;1+2&quot;, 1 )</div>
<div class="line">&quot;rel of 1+2&quot; = rel( &quot;1+2&quot;, + )</div>
<div class="line">&quot;obj of 1+2&quot; = obj( &quot;1+2&quot;, 2 )</div>
<div class="line"> </div>
<div class="line">12 &quot;(1+1)&quot; = +( 1, 1 )</div>
<div class="line">14 &quot;result = (1+1)&quot; = exex_obj( result, &quot;(1+1)&quot; ) </div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    new ctx {</div>
<div class="line">        $.$ -&gt; $</div>
<div class="line">        &quot;(1+1)&quot; -&gt; $ent</div>
<div class="line">        1 -&gt; $sub</div>
<div class="line">        1 -&gt; $obj</div>
<div class="line">        result -&gt; $rel</div>
<div class="line">    } </div>
<div class="line">    exec( ctx, &quot;+&quot;) -&gt; result = 2</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">2 - значение отношения</div>
</div><!-- fragment --><p>Ф-я x+y Отношение - чистое бытие, пример. функция сложения записанная на бумаге Отношение в качестве сущности - сущность операции сложения определённая записью на бумаге - принцип (способ взаимодействия) Использование отношения в качестве сущности отношения - осуществление операции сложения определённой записью на бумаге - процесс</p>
<p>Качество объекта отношения - Качество субъекта отношения -</p>
<p>Объективация - Субъективация -</p>
<p>осуществление - это исполнение сущности отношения в контексте исполнения (проявление сущности отношения в месте проявления ) отношения в МО хранятся шаблонами, поэтому требуют субъективации перед исполнением, т.е. из отношения надо породить контекст исполнения, обработав при этом местоимения объективация это объективация субъективности, т.е. нам надо получить объективное значение отношения и записать его в МО в объективном виде, т.е. в виде триплета: субъект, сущность, объект</p>
<p>у РВМ всего есть 3 фазы работы:</p><ol type="1">
<li>субъективация</li>
<li>осуществление</li>
<li>объективация</li>
</ol>
<p>эти фазы отвечают за движение РВМ в 3х-мерном пространстве состояний 3 измерения это соответственно:</p><ol type="1">
<li>движение от объекта (отношение МО) к субъекту (контекст РВМ) - субъективация</li>
<li>движение от сущности отношения к отношению (от сути к бытию) - осуществление</li>
<li>движение от субъекта (контекст РВМ) к объекту (отношение МО) - объективация</li>
</ol>
<p>всем этим фазам и измерениям соответствуют свои операции:</p><ol type="1">
<li>субъективация - чтение отношения в новый контекст</li>
<li>осуществление - исполнение отношения</li>
<li>объективация - запись/изменение отношения</li>
</ol>
<hr  />
 <pre class="fragment">Фундаментальные вопросы
</pre><p> ?. поток управления сущности, 1 поток на 1 сущность (нейросеть) или 1 поток на N сущностей (программа) Проверка условия (предиката) в программе эквивалентна изолированию результатов действий потоков управления по вычислению логической функции. Там где в логической схеме отбразывается значение логической функции, в программе этой функции не передаётся поток управления. Данный факт хорошо виден в графических ускорителях, где проверка условий (предикатов) более затратна, чем отброс значения логической функции. Поэтому в них всегда вычисляется все логические функции, а потом отбрасывается не нужные результаты.</p>
<p>При многопоточном исполнении всегда проще вычислять все логические функции, а потом делать проверку результатов.</p>
<p>?. модульность (1 поток на 1 сущность) на 0 уровне мета программирования ?. идентификация экземпляров контекстов исполнения сущности ?. контекст исполнения сущности - экземпляра отношения - это её воплощение, он содержит отражения 3х аспектов сущности ?. сущность это процесс исполнения экземпляра отношения, этот процесс порождает проекцию ?. отношение проецирования исполняет объект во внешнем контексте используя субъект как локальную область видимости ?. только exec или exec + view</p>
<hr  />
<p> Мысли</p>
<p>Время жизни сущности ограничено временем жизни контекста её исполнения. Проекция сущности существует только в контексте её исполнения. При исполнении сущности происходит её инстанцирование в контект исполнения. Далее поток управления создает её проекцию, и пока поток управления находится в контексте исполнения данной сущности, её проекция обновляется.</p>
<p>В общем случае для получения проекции сущности в языке целевой платформы, необходимо сначала получить такой же тип проекции отношения данной сущности, а потом его исполнить в контексте данной сущности.</p>
<p>Так как проекция сущности это отображение её МО, то по сути проекция это всегда МО. Проекция может быть близка или далека от МО самой сущности, и могут быть использованы разныме методы рефракции проекции в МО.</p>
<p>Проекция МО может быть удобной для модификации и доступа к её МО, а может быть не удобной, например если это скомпилированный код. json как проекция МО удобен тем, что это с одной стороны гибрид сигмента данных и кода, а с другой стороны имеет иерахическую адресацию.</p>
<p>Фактически проекция сущности возникает и существует пока сущность инстанцирована в контексте своего исполнения потоком управления. Время жизни проекции === время жизни сущности в контексте. Пока сущность исполняется, её проекция в контексте изменяется.</p>
<p>Байткод это просто часть проекции сущности, в то время как вся проекция МО сущности это гибрид сегмента кода и данных. Данные подразумевают адресацию, поэтому полная проекция МО сущности это байткод + структура данных.</p>
<p>Для удобства рефлекции json проекции в МО должна быть возможность отображать триединые сущности в json и/или иметь возможность адресоваться в МО из json.</p>
<p>Таким образом получается, что МО это суть проекции, полученная рефлекцией проекции, а проекция МО это представление МО, полученная проецированием.</p>
<p>Для получения проекции сущности необходимо исполнить в контексте данной сущности проекцию её отношения. Исполнение сущности это и есть получение её проекции, потому что проекция создаётся и обновляется только в процесе исполнения сущности в контексте её исполнения.</p>
<p>Для исполнения проекции отношения сущности необходимо создать вложенный контекст исполнения сущности отношения.</p>
<p>Отношение есть активный поток информации (от меня: от объекта к субъекту), чем этот поток больше, тем ценнее отношение, при условии, что поток приводится в действие напряжением релевантности. (Джон Перри Барлоу)</p>
<pre class="fragment">Существует 2 типа исполнения МО:
</pre><ol type="1">
<li>непосредственная интерпретация МО 1.1 json 1.2 bytecode</li>
<li>компиляция дерева МО через интерпретацию МО и проецирование в целевой язык и исполнение</li>
</ol>
<hr  />
 <pre class="fragment">Этапы
</pre><p> *. Анализ мыслей и планов по МО *. Формат хранения документации с хэштегами в МО (с прицелом на модель знаний) *. Переход на jsonpointer? *. Поддержка адресации в БД и файлах (+удобство, -безопасность) *. Разделение контекста на локальный и глобальный *. 64битная сборка jsonRVM и их идентификация *. Проверка производительности и возможностей JSONCONS (tags, refs and bytearrays) The jsoncons data model supports the familiar JSON types - nulls, booleans, numbers, strings, arrays, objects - plus byte strings. In addition, jsoncons supports semantic tagging of datetimes, epoch times, big integers, big decimals, big floats and binary encodings. This allows it to preserve these type semantics when parsing JSON-like data formats such as CBOR that have them.</p>
<p>*. Многопоточность в jsonRVM</p>
<p>*. План объединения jsonRVM + phpRVM</p>
<p>*.* Как хранить МО в SQL БД? (переход от хранения сущностей к хранению json МО) *.* двунаправленный конвертор чистой МО &lt;-&gt; json для проверки корректности проецирования МО в json *.* Переделать адресацию скомпилированных функций *.* переделать PHPRVM по образу jsonRVM *.*.* sub, rel, obj переделать на $sub, $rel, $obj *.*.* вернуть код PHPView из БД в скрипт PHP *.* шаблон мультиязыковой RVM (Обобщённый код виртуальной машины)</p>
<p>*.* На какой основе объединять? единый RVM bytecode или json как байткод?</p>
<p>*.* шаблоны проекции? сущности(модель сущности) и куда они проецируются (в контекст исполнения) *.* RESTfull WebAPI</p>
<p>*. доделать калькулятор, что бы он работал на двух RVM *. Иерархическая адресация в модели проекции объекта и субъекта транслируется в модель подготовки объекта и субъекта отношения *. RMDesigner (на чем?, нужна многопоточность)</p>
<p>*. проекция МО в естественный язык *. Формат хранения знаний в МО *. обучение нейросетей на основе случайно сгенерированных МО Нейросеть на выходе выдает иерархический хэштэг сущности *. нейросеть для распознавания МО в естественном языке *. База знаний с языковым интерфейсом</p>
<p>*. pyRVM для нейросетей *. ArduinoRVM для IOT *. jsRVM для браузеров</p>
<p>*. проекция МО -&gt; plantuml</p>
<hr  />
<p> Обобщенный код виртуальной машины</p>
<p>1.</p>
<hr  />
<p> // &mdash;Ближний план phpRVM&mdash; // // 1. доделать калькулятор...................................................5% // 2. обновить сайт.........................................................50% // // 3. разобрать файл Rmodel.php что бы потом его удалить // * избавиться от класса Rmodel...........................................50% // * PHPExec.php - exec RelId in EntId contex // * PHPDebug.php - exec RelId in EntId contex (debug mode) // // 4. создать отображение REST WebAPI Entity.php: // * EntityGet - view entity in json // * EntityPost - edit entity // * EntityPut - create entity in json // * EntityDelete - removes entity // // 5. сделать несколько простых примеров и проработать базовый словарь для этого: // * переменные и их конструкторы.........................................50% // * структуры // * ссылки...............................................................50% // * операции // * циклы // * конструкторы объектов // // 6. запихать весь возможный код в БД......................................33% // 7. разобраться с хранением картинок в МО..................................0% // 8. сделать 1-2 примера самомодифицирующихся моделей......................10%</p>
<p>// * подумать над именами колонок в БД и переделать числовые идентификаторы в текстовые для распределения МО по сетевым узлам // * сделать генерацию EngView и RusView.....................................0% // * разграничить права, запуск и отображение только по паролю // * Flush all changes in Rmodel // * разграничение на проекты/хост-узлы? // * импорт/экспорт моделей/проектов/хост-узлов // * интеграция с PHP JSTP // * браузерная jsRVM (в качестве Йави использовать DOM)......................0% // * добавить в визуальные таблицы древовидное разворачивание структуры сущностей // * сделать добавление сущностей в древовидной структуре сущностей // * переделать на $EC........................................................0% // (Каждая сущность это одновременно шаблон структуры и шаблон программы по формированию этой структуры) //</p>
<p>//////////////////////////////////////////////////////////////////////////////// // &mdash;Виды действий над сущностями&mdash; // // 2 функции - 2 базовых отношения: // // 1. Исполнение сущности: // отвечает на вопрос: Как получить проекцию? exec() - исполняет проекцию сущности в контексте другой сущности, // если проекции нет то создаёт её используя view() // это активация контроллера который должен спроецировать модель-объект в представление-субъект // исполнить можно только проекцию сущности в качестве контроллера в экземпляре отношения другой сущности // эта функция всегда вызывается для исполнения отношения Rel в экземпляре отношения $Ent // исполнится может только проекция отношения в текущий язык, т.е. $Ent['Rel']['PHPView'] // Функция реализуется на целевой платформе // // 2. Отображение сущности: // отвечает на вопрос: Куда спроецировать? view() - если в субъекте нет проекции то создаёт проекцию в нём, // если проекции вообще нет то вызывает exec() // создать проекцию объекта в субъекте // делает конкатенацию к проекции субъекта // возвращает ссылку на созданную проекцию // Функция реализуется телом корневой сущности</p>
<p>// PHPExec(): исполнение экземпляра отношения это создание или обновление проекции сущности // после обновления все кто использует данную сущность по ссылке будут использовать // обновлённый вариант проекции сущности // исполнение проекции контроллера в итоге должно изменить контекстную сущность $Ent и возможно агрегат $Ent['Sub'] /*</p><ol type="1">
<li>исполнение сущности это исполнение её PHPView в eval() который сначала надо получить</li>
<li>т.к. в итоге мы получаем определённую проекцию то в контекст eval надо передать предыдущее её состояние</li>
<li>после исполнения разумно закэшировать результат, что бы в след раз только обновить его</li>
</ol>
<p>функция PHPExec() вызывается в следующих случаях:</p><ol type="1">
<li>извне для исполнения контроллера RelId в контексте EntId для получения результата проецирования</li>
<li>внутри самой себя для получения PHP проекции контроллера и получения проекции EntId</li>
<li>внутри закэшированнх тел сущностей базового словаря</li>
</ol>
<p>Возможно в структурной проекции сущности разделить элементы и атрибуты:</p><ol type="1">
<li>элементов может быть много и одного типа, они составляют внутреннюю структуру сущности элементы формируются при участии данной сущности в качестве субъекта в других отношениях</li>
<li><p class="startli">атрибутов может быть только по 1 каждого типа, это проекции данной сущности атрибуты формируются при исполнении отношений в контексте данной сущности: $Ent[RelName] = PHPExec( RelId, EntId )</p>
<p class="startli">Возможно атрибуты всего лишь поименованные ссылки на элементы!</p><ul>
<li>проектор определяет метрику проекции, и в соответствии с этой метрикой располагает её в субъекте</li>
<li>у проектора PHPView метрика = 1</li>
<li>отношение всегда имеет уровень мета +1:</li>
</ul>
<ol type="a">
<li>если субъект и объект данные, то отношение есть программа</li>
<li>если субъект и объект программа, то отношение есть генератор программы т.е. метапрограмма</li>
<li>если субъект и объект метапрограмма, то отношение есть генератор метапрограммы т.е. метаметапрограмма и т.д.</li>
</ol>
<ul>
<li>адресация в метрике субъекта должна производиться контроллером</li>
<li>тип проекции которую создаёт контроллер по модели объекта зависит от контроллера,</li>
<li>адрес может определять как контроллер так и модель</li>
</ul>
<p class="startli">Пример контроллера проецирующего точку: { $PHPView = &amp;$Ent['Obj']['Color']; $Ent['Sub'][ $Ent['Obj']['x'] ][ $Ent['Obj']['y'] ] = &amp;$PHPView; } Этот код будет исполнен в eval() при вызове PHPExec( PointIdXXXX, 0 );</p>
<p class="startli">В общем случае PHPView может быть сложным иерархическим объектом, надо решить как его исполнять? Как то сериализовывать в сплошной код, либо усложнить исполнитель - виртуальную машину.</p>
<p class="startli">если сущность есть замкнутая структура, то её проекция должна иметь замыкание с именем её отношения */ </p><hr  />
</li>
</ol>
<p>У сущности есть 3 возможных качества в которых она может быть проявлена в других сущностях:</p><ol type="1">
<li>объект определяющий модель</li>
<li>субъект определяющий представление</li>
<li>отношение определяющий контроллер</li>
</ol>
<p>У каждого проявления качества есть 3 определяющих параметра:</p><ol type="1">
<li>сущность, которая проявляет качество: объекта , субъекта , отношения</li>
<li>сущность, в которой проявляется одно из качеств другой сущности: модель , представление , контроллер</li>
<li>сущность, характеризующая качество проявления: объективное, субъективное, качественное</li>
</ol>
<p>1-3-9-27-81 1-4-13-40-121 </p><hr  />
 <pre class="fragment">Словарь
</pre><p> сущность объект субъект отношение модель представление контроллер качество проявление определять</p>
<hr  />
<p>Немного описания содержится в комментариях в файле jsonRVM.h</p>
<p>jsonRVM это виртуальная машина для интерпретации проекции языка метапрограммирования Модели Отношений. Почему проекции, потому что сама по себе Модель Отношений (далее МО) это именно модель типа UML, и в чистом виде может храниться только структуре типа таблицы базы данных.</p>
<p>Предыдущей реализацией RVM была серверная PHPRVM, но для неё МО приходилось создавать вручную прописыванием строк в таблице БД. Это было очень медленно и неудобно. Некоторое время назад на работе понадобилось создать инфраструктуру тестирования WebAPI облачного сервиса, вот так и родилась идея создать jsonRVM для непосредственной интерпретации проекции МО в json.</p>
<p>Теперь объясню попроще, что это и как работает и как например это можно было бы применить в игрострое.</p>
<p>В современном мире json постепенно из простого формата сериализации превратился в нечто большее, можно сказать в универсальный формат описания и представления любых данных. Большая часть трафика интернета это именно json. Уже даже многие реляционные базы данных поддерживают работу с json в запросах SQL. json используют в конфигах, в описаниях GUI и т.д.</p>
<p>НО нет возможности каким либо образом написать алгоритмы на самом json, ведь это формат описания данных, а не логики. Тут только остаётся вариант прикрутить какой нибудь легковесный js интерпретатор, ну либо вообще писать игру на js. И вот тут то как раз хорошо в json формат мэппится МО, потому что МО это модель взаимосвязей сущностей, а значит представляет из себя данные. В обычных языках программирования всегда есть четкое разделение на данные и алгоритмы, на сегмент данных и сегмент кода. А вот МО является как бы одновреименно и кодом и данными, потому что это Сущностно-Ориентированное Программирование.</p>
<p>Каждая сущность в МО это аналог активного объекта в ООП, т.е. это экземпляр объекта обладающего и состоянием и потоком управления, исполняющим некий метод этого объекта.</p>
<p>Теперь ближе к делу, как именно это всё реализуется в json. Для хранения описания сущностей в json, был искуственно введён новый тип узла в дереве данных json, т.е. кроме типов null, integer, float, string, object и array добавлен тип entity. С точки зрения json это обычный узел типа json объект, но у него есть как минимум поле с именем $rel определяющее сущность-отношение. По этому признаку jsonRVM определяет, что это не просто json данные, а именно сущность, и интерпретировать её надо по другому. Кроме поля $rel, сущность опционально содержит поля $obj и $sub, а так же может содержать поля с различными внутренними атрибутами сущности.</p>
<p>jsonRVM может воспринимать json по разному, либо как просто данные либо как проекцию МО которую надо исполнить. На вход jsonRVM всегда передаётся проекция МО корневой сущности, которую необходимо исполнить, т.е. найти её представление. Каждая сущность в МО это экземпляр отношения между двумя сущностями: субъектом и объектом. Тут важно не путать понятие с объектом из ООП. В МО используется понятие объекта именно в философском смысле.</p>
<p>Приведу на всякий случай определения из вики: Объе?кт (лат. objectum «предмет») — философская категория, обозначающая вещь, явление или процесс, на которые направлена предметно-практическая, управляющая и познавательная деятельность субъекта (наблюдателя); при этом, в качестве объекта может выступать и сам субъект. Субъектом может быть личность, социальная группа или всё общество. </p><pre class="fragment">Субъе?кт (лат. subjectum «лежащее внизу; находящееся в основе») — носитель
</pre><p> деятельности, сознания и познания[1]; индивид, познающий внешний мир (объект) и воздействующий на него в своей практической деятельности; человек или консолидированная группа лиц (напр., научное сообщество), общество, культура или даже человечество в целом, противопоставляемые познаваемым или преобразуемым объектам[2].</p>
<p>Если смотреть с точки зрения ООП то и объект и субъект в принципе будут объектами.</p>
<p>С точки зрения исполнения сущностей, т.е. экземпляров отношений, каждую сущность можно понимать как троицу MVC: Model = object View = subject Controller = relation</p>
<p>В экземпляре отношения в качестве объекта, субъекта и отношения выступают тоже такие же сущности, поэтому MVC превращается в тройное дерево, а шаблон уже будет называться ScMHMVC (Self-compiled Multi-layered Hierarchical Model View Controller). Практически это означает, что объектом может выступать результат проецирования из другого слоя MVC, субъектом может являться элемент дерева MVC, а контроллером результат исполнения другой экземпляр троицы MVC, либо представление и другой троицы MVC.</p>
<p>Но это всё довольно сложно, и возможно не обязательно понимать для того того что бы начать что то писать на json МО.</p>
<p>Разберём простенький пример из каталога test, а именно version.json: { "$rel" : [ { "$obj" : "#/RVM_version", "$rel" : "#/=", "$sub" : "/RVM_version" }, { "/meta" : "#/json/meta" } ] }</p>
<p>Для исполнения этой модели необходимо запустить в командной строке: jsonRVM.exe version.json</p>
<p>Что мы тут видим, корневой сущностью является искусственно введённый в json узел entity (это json object с полем $rel), значит это именно сущность МО которую необходимо интерпретировать, и для этого надо создать новый контекст исполнения. Отсутствие полей $obj и $sub говорит о том, что они топологически замкнуты на саму это корневую сущность, а значит в контексте исполнения будут указывать и результат проецирования корневой сущности. Отношением у этой сущности выступает json array, а это значит, что это pipeline из сущностей (или их проекций в json) которые необходимо последовательно исполнить. Первой сущностью в pipeline является узел json entity, т.е. надо создать вложенный контекст исполнения для исполнения этой сущности. У неё заданы все поля $obj, $rel, $sub, т.е. у сущности отсутствуют топологические замыкания на саму себя. Если в полях $obj, $rel, $sub находится строка то это ссылка по аналогии со стандартной $ref, где # указывает на корень json документа, в нашем случае проекция МО корневой сущности.</p>
<p>Семантика json значений в полях "$sub", "$rel", "$obj" json объекта описывающего сущность:</p>
<ol type="1">
<li>Number - адрес json объекта в памяти</li>
<li>Boolean - непосредственное значение = true/false</li>
<li>String - иерархический путь к сущности относительно текущего контекста исполнения</li>
<li>Object - json объект определяющий непосредственное значение сущности</li>
<li>Array - json массив определяющий непосредственное значение сущности</li>
<li>Null - значение по умолчанию, пустой указатель на сущность обозначающий топологическая замкнутость на текущую проекцию сущности в контексте исполнения EV[""]</li>
<li>Entity - непосредственное описание другой сущности</li>
</ol>
<p>Перед тем как рассказывать далее надо сделать небольшое отступление. Дело в том, что для нормальной работы RVM нужен хотя бы минимальный базовый словарь сущностей. Прямо в jsonRVM.exe закомпилен базовый словарь сущностей, а так же версия RVM которая была использована при компиляции словаря. Для просмотра этого словаря необходимо в качестве аргумента при запуске jsonRVM.exe передать саму jsonRVM.exe, т.е. запустить в командной строке: jsonRVM.exe jsonRVM.exe</p>
<p>После парсинга version.json виртуальная машина автоматически догружает в корневую сущность базовый словарь сущностей, что бы была возможность дальнейшего исполнения МО корневой сущности.</p>
<p>Разберём конкретные значения: { "$obj" : "#/RVM_version", - указатель на версию базового словаря сущностей "$rel" : "#/=", - указатель на сущность идентичного проецирования, т.е. присваивания "$sub" : "/RVM_version" - указатель на свойство RVM_version в локальной области видимости текущего контекста исполнения }</p>
<p>Локальной области видимости это такой же json узел, явно заданный при исполнении сущности. Аналогом является локальная область видимости при исполнении метода класса, обычно размещается на стэке процессора.</p>
<p>Для корневой сущности локальная область видимости это результат исполнения МО корневой сущности, это именно то что jsonRVM в конце исполнения выводит в консоль.</p>
<p>Второй сущностью исполняемой в pipeline будет json object { "/meta" : "#/json/meta" - компактная запись отношения проецирования объекта в субъект }</p>
<p>Вот пояснение по исполнению json значений: Семантика json значений при исполнении (json как байткод RVM):</p>
<ol type="1">
<li>Number - адрес скомпилированного тела сущности, которое необходимо исполнить RVM</li>
<li>Boolean - true : спроецировать / false : не проецировать объект в субъект</li>
<li>String - иерархический путь к json значению относительно контекста исполнения, которое необходимо исполнить RVM</li>
<li>Object - множество пар "имя поля": значение поля, где значение поля - иерархический путь к json значению относительно контекста исполнения, которое необходимо исполнить имя поля - иерархический путь к json значению относительно контекста исполнения, куда необходимо спроецировать сущность вычисление проекций множества пар может происходить параллельно, в многопоточном режиме</li>
<li>Array - массив значений json которые необходимо последовательность исполнить в текущем контексте исполнения, при этом результат предыдущего исполнения всегда доступен для следующей исполняющейся сущности</li>
<li>Null - возврат текущей контекстной проекции в саму себя, т.е. по сути отсутствие действия над текущей проекцией в контексте исполнения</li>
<li>Entity - сущность, для которой надо создать дочерний контекст и исполнить</li>
</ol>
<p>В итоге свойство #/json/meta будет записано в свойство meta локальной области видимости. Ну вот как то так. А вообще сущностно-ориентированное программирование вот так в 2х словах не объяснить, потому что это более фундаментальная концепция по сравнению с процедурным программированием или ООП.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Ent = &lt;Sub, Rel, Obj&gt;</h1>
<p>Rel_SO = &lt;Sub, Obj&gt; - объективация Ent = &lt;Rel, Rel_SO&gt; - субъективация </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
